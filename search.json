[{"path":"https://robinhankin.github.io/stokes/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor covenant code of conduct","title":"Contributor covenant code of conduct","text":"members, contributors, leaders wish make participation community pleasant productive experience everyone. try act interact ways contribute open, welcoming, inclusive, healthy community. assume good faith, per WP:AGF. Examples behaviour contributes positive environment community include: Demonstrating empathy kindness toward people Communicating respectfully differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community","code":""},{"path":"https://robinhankin.github.io/stokes/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to stokes","title":"Contributing to stokes","text":"Thank considering contributing stokes! appreciate interest making project better. Please read adhere Code Conduct maintain safe, welcoming, inclusive environment. Various forms contributions welcome: Bug Reports: Feel free report bugs encounter. Documentation: Typos, clarity issues, missing guides: help welcome . Feature Discussions/Requests: Got idea? Open issue discuss potential. Code Contributions: code contributions welcome. Tests checks run CI, however locally one can use: devtools::test(). Ideally change documented. Major changes vignettes.","code":""},{"path":"https://robinhankin.github.io/stokes/articles/Alt.html","id":"further-properties-of-alt","dir":"Articles","previous_headings":"","what":"Further properties of Alt()","title":"The `Alt()` function in the `stokes` package","text":"theorem 4.3, Spivak proves following statements: T tensor, \\operatorname{Alt}(T) alternating \\omega alternating [writes \\omega\\\\Lambda^k(V)] \\operatorname{Alt}(\\omega)=\\omega T tensor, \\operatorname{Alt}(\\operatorname{Alt}(T))=\\operatorname{Alt}(T). demonstrated first point . second, need construct tensor alternating, show Alt() change : third point, idempotence also easy:","code":"P <- as.ktensor(1+diag(2),c(-7,7)) P ## A linear map from V^2 to R with V=R^2: ##          val ##  1 2  =    7 ##  2 1  =   -7 P == Alt(P) ## [1] TRUE P <- rtensor()*6 # the \"6\" avoids numerical round-off issues Alt(Alt(P))==Alt(P)   # should be TRUE ## [1] TRUE"},{"path":"https://robinhankin.github.io/stokes/articles/Alt.html","id":"wedge-product","dir":"Articles","previous_headings":"","what":"Wedge product","title":"The `Alt()` function in the `stokes` package","text":"Spivak defines wedge product follows. Given alternating forms \\omega\\\\Lambda^k(V) \\eta\\\\Lambda^l(V) \\omega\\wedge\\eta=\\frac{(k+l)!}{k!l!}\\operatorname{Alt}(\\omega\\otimes\\eta) example: see omega alternating construction, eta alternating virtue Alt(). Thus tensor \\omega\\wedge\\eta defined per Spivak’s definition, may calculate directly: Observe tensor \\omega\\otimes\\eta (returned default argument give_kform=FALSE sent Alt()) quite long, 2\\cdot 5!=240 nonzero components, printed full. may verify f() alternating evaluating randomly chosen point \\left(\\mathbb{R}^7\\right)^5: see verification f() fact alternating: writing matrix V terms five vectors V=\\left[v_1,v_2,v_3,v_4,v_5\\right], v_i\\\\mathbb{R}^7, see f{\\left(v_1,v_2,v_3,v_4,v_5\\right)}=-f{\\left(v_2,v_1,v_3,v_4,v_5\\right)}.","code":"omega <- as.ktensor(2+diag(2),c(-7,7)) eta <- Alt(ktensor(6*spray(matrix(c(1,2,3,1,4,7,4,5,6),3,3,byrow=TRUE),1:3))) omega ## A linear map from V^2 to R with V=R^3: ##          val ##  2 3  =    7 ##  3 2  =   -7 eta ## A linear map from V^3 to R with V=R^7: ##            val ##  1 4 7  =    2 ##  3 2 1  =   -1 ##  4 6 5  =   -3 ##  1 7 4  =   -2 ##  4 5 6  =    3 ##  7 1 4  =    2 ##  4 1 7  =   -2 ##  4 7 1  =    2 ##  6 5 4  =   -3 ##  6 4 5  =    3 ##  5 4 6  =   -3 ##  1 3 2  =   -1 ##  2 1 3  =   -1 ##  1 2 3  =    1 ##  2 3 1  =    1 ##  7 4 1  =   -2 ##  3 1 2  =    1 ##  5 6 4  =    3 Alt(omega %X% eta,give_kform = TRUE) ## An alternating linear map from V^5 to R with V=R^7: ##                val ##  2 3 4 5 6  =  2.1 ##  1 2 3 4 7  =  1.4 f <- as.function(Alt(omega %X% eta)) V <-  matrix(rnorm(35),ncol=5) c(f(V),f(V[,c(2:1,3:5)])) ## [1] -0.852457  0.852457"},{"path":"https://robinhankin.github.io/stokes/articles/Alt.html","id":"further-further-properties-of-alt","dir":"Articles","previous_headings":"Wedge product","what":"Further further properties of Alt()","title":"The `Alt()` function in the `stokes` package","text":"Spivak goes prove following three statements. S,T tensors \\omega,\\eta,\\theta alternating tensors arity k,l,m respectively, \\operatorname{Alt}(S)=0, \\operatorname{Alt}(S\\otimes T)=\\operatorname{Alt}(T\\otimes S)=0. \\operatorname{Alt}(\\operatorname{Alt}(\\omega\\otimes\\eta)\\otimes\\theta) =\\operatorname{Alt}(\\omega\\otimes\\eta\\otimes\\theta)= \\operatorname{Alt}(\\omega\\otimes\\operatorname{Alt}(\\eta\\otimes\\theta)) (\\omega\\wedge\\eta)\\wedge\\theta = \\omega\\wedge(\\eta\\wedge\\theta) = \\frac{(k+l+m)!}{k!l!m!}\\operatorname{Alt}(\\omega\\otimes\\eta\\otimes\\theta). Taking points turn. Firstly \\operatorname{Alt}(S\\otimes T)=\\operatorname{Alt}(T\\otimes S)=0: secondly, \\operatorname{Alt}(\\operatorname{Alt}(\\omega\\otimes\\eta)\\otimes\\theta)   =\\operatorname{Alt}(\\omega\\otimes\\eta\\otimes\\theta)=   \\operatorname{Alt}(\\omega\\otimes\\operatorname{Alt}(\\eta\\otimes\\theta)): Verifying third identity (\\omega\\wedge\\eta)\\wedge\\theta =   \\omega\\wedge(\\eta\\wedge\\theta) =   \\frac{(k+l+m)!}{k!l!m!}\\operatorname{Alt}(\\omega\\otimes\\eta\\otimes\\theta) needs us coerce k-form k-tensor:","code":"(S <- as.ktensor(rbind(c(1,2,3,3),c(1,1,2,3)),1000:1001)) ## A linear map from V^4 to R with V=R^3: ##               val ##  1 1 2 3  =  1001 ##  1 2 3 3  =  1000 Alt(S)  # each row of S includes repeats ## The zero linear map from V^4 to R with V=R^n: ## empty sparse array with 4 columns T <- rtensor() c(is.zero(Alt(S %X% T)), is.zero(Alt(T %X% S))) ## [1] TRUE TRUE omega <- Alt(as.ktensor(rbind(1:3),6)) eta <- Alt(as.ktensor(rbind(4:5),60)) theta <- Alt(as.ktensor(rbind(6:7),14))  omega ## A linear map from V^3 to R with V=R^3: ##            val ##  3 2 1  =   -1 ##  3 1 2  =    1 ##  2 3 1  =    1 ##  2 1 3  =   -1 ##  1 3 2  =   -1 ##  1 2 3  =    1 eta ## A linear map from V^2 to R with V=R^5: ##          val ##  5 4  =  -30 ##  4 5  =   30 theta ## A linear map from V^2 to R with V=R^7: ##          val ##  7 6  =   -7 ##  6 7  =    7 f1 <- as.function(Alt(Alt(omega %X% eta) %X% theta)) f2 <- as.function(Alt(omega %X% eta %X% theta)) f3 <- as.function(Alt(omega %X% Alt(eta %X% theta))) V <- matrix(rnorm(9*14),ncol=9) c(f1(V),f2(V),f3(V)) ## [1] -3.154794 -3.154794 -3.154794 omega <- rform(2,2,19) eta <- rform(3,2,19) theta <- rform(2,2,19)  a1 <- as.ktensor(omega ^ (eta ^ theta)) a2 <- as.ktensor((omega ^ eta) ^ theta) a3 <- Alt(as.ktensor(omega) %X% as.ktensor(eta) %X% as.ktensor(theta))*90  c(is.zero(a1-a2),is.zero(a1-a3),is.zero(a2-a3)) ## [1] TRUE TRUE TRUE"},{"path":"https://robinhankin.github.io/stokes/articles/Alt.html","id":"argument-give_kform","dir":"Articles","previous_headings":"","what":"Argument give_kform","title":"The `Alt()` function in the `stokes` package","text":"Function Alt() takes Boolean argument give_kform. using Alt() give_kform taking default value FALSE, means returns object class ktensor. However, alternating form can much efficiently represented object class kform, returned give_kform TRUE. verify two options return identical objects: , see S1 rather extensive object, 120 terms. However, argument give_kform = TRUE passed Alt() get kform object much succinct: Verification objects S1 SA1 object: see agreement within numerical error.","code":"(rand_tensor <- rtensor(k=5,n=9)*120) ## A linear map from V^5 to R with V=R^9: ##                 val ##  7 3 6 4 7  =   120 ##  8 1 3 4 4  =   240 ##  2 6 4 5 7  =   360 ##  8 4 2 8 8  =   840 ##  7 1 3 5 1  =   480 ##  1 6 4 7 6  =   600 ##  6 7 3 3 4  =  1080 ##  9 2 3 5 3  =   720 ##  6 5 6 5 4  =   960 S1 <- Alt(rand_tensor)  # 120 terms, too long to print all of it summary(S1) ## A ktensor object with 120 terms.  Summary of coefficients:  ##  ## a disord object with hash 866c13390582e2f7e562be3e046abda44be30079  ##  ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##      -3      -3       0       0       3       3  ##  ##  ## Representative selection of index and coefficients: ##  ## A linear map from V^5 to R with V=R^7: ##                val ##  7 6 5 4 2  =    3 ##  2 6 4 7 5  =   -3 ##  7 4 2 6 5  =    3 ##  2 7 6 4 5  =   -3 ##  4 6 2 5 7  =   -3 ##  6 5 2 4 7  =   -3 (SA1 <- Alt(rand_tensor,give_kform=TRUE)) ## An alternating linear map from V^5 to R with V=R^7: ##                val ##  2 4 5 6 7  =    3 V <- matrix(rnorm(45),ncol=5) LHS <- as.function(S1)(V) RHS <- as.function(SA1)(V) c(LHS=LHS,RHS=RHS,diff=LHS-RHS) ##           LHS           RHS          diff  ##  2.386928e+01  2.386928e+01 -1.065814e-14"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/contract.html","id":"contraction-of-products","dir":"Articles","previous_headings":"","what":"Contraction of products","title":"Functions `contract()` and `contract_elementary()` in the `stokes` package","text":"Weintraub (2014) gives us following theorem, k-form \\phi l-form \\psi: \\left(\\phi\\wedge\\psi\\right)_\\mathbf{v} = \\phi_\\mathbf{v}\\psi + (-1)^k\\phi\\wedge\\psi_\\mathbf{v}. can verify numerically k=4,l=5: theorem verified. note passing object quite complicated: may also switch \\phi \\psi, remembering change sign:","code":"phi <- rform(terms=5,k=3,n=9) psi <- rform(terms=9,k=4,n=9) v <- sample(1:100,9) contract(phi^psi,v) ==  contract(phi,v) ^ psi - phi ^ contract(psi,v) ## [1] TRUE summary(contract(phi^psi,v)) ## A kform object with 47 terms.  Summary of coefficients:  ##  ## a disord object with hash d6cdb7213e60a9d847f1752a839f18b1de98bc57  ##  ##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  ## -2943.00  -516.00    48.00    44.47   768.00  2625.00  ##  ##  ## Representative selection of index and coefficients: ##  ## An alternating linear map from V^6 to R with V=R^9: ##                    val ##  1 2 4 6 8 9  =    390 ##  1 2 3 5 6 7  =    420 ##  1 2 3 4 6 8  =   -840 ##  2 5 6 7 8 9  =   1605 ##  1 2 3 6 7 9  =    355 ##  1 2 3 6 8 9  =  -1200 contract(psi^phi,v) ==  contract(psi,v) ^ phi + psi ^ contract(phi,v) ## [1] TRUE"},{"path":"https://robinhankin.github.io/stokes/articles/contract.html","id":"repeated-contraction","dir":"Articles","previous_headings":"","what":"Repeated contraction","title":"Functions `contract()` and `contract_elementary()` in the `stokes` package","text":"course possible contract contraction. \\phi k-form, \\left(\\phi_\\mathbf{v}\\right)_\\mathbf{w} k-2 form \\left(\\phi_\\mathbf{u}\\right)_\\mathbf{v}\\left(\\mathbf{w}^1,\\ldots,\\mathbf{w}^{k-2}\\right)=\\phi\\left(\\mathbf{u},\\mathbf{v},\\mathbf{w}^1,\\ldots,\\mathbf{w}^{k-2}\\right) straightforward realise package: contract() allows us perform contractions one operation: pass matrix M contract() interpreted repeated contraction columns M: can verify directly system works intended. lines strip successively columns argument V contract : see agreement within numerical precision. pass three columns contract() result 0-form: , result coerced scalar returned form disord object; order work formal 0-form (represented package spray zero-column index matrix) can use lost=FALSE argument: thus returning 0-form. iteratively contract k-dimensional k-form, return determinant, may verified follows: see agreement within numerical error.","code":"(phi <- rform(2,5)) ## An alternating linear map from V^5 to R with V=R^7: ##                val ##  1 4 5 6 7  =   -2 ##  2 4 5 6 7  =   -1 u <- c(1,3,2,4,5,4,6) v <- c(8,6,5,3,4,3,2) contract(contract(phi,u),v) ## An alternating linear map from V^3 to R with V=R^7: ##             val ##  2 5 6  =    10 ##  1 4 7  =     2 ##  4 5 7  =    73 ##  1 4 5  =    20 ##  2 4 7  =     1 ##  1 5 6  =    20 ##  2 4 6  =   -14 ##  1 6 7  =    -2 ##  2 6 7  =    -1 ##  2 4 5  =    10 ##  5 6 7  =    73 ##  4 6 7  =   -90 ##  1 4 6  =   -28 ##  4 5 6  =  -122 M <- cbind(u,v) contract(contract(phi,u),v) == contract(phi,M) ## [1] TRUE (o <- kform(spray(t(replicate(2, sample(9,4))), runif(2)))) ## An alternating linear map from V^4 to R with V=R^9: ##                     val ##  3 7 8 9  =  -0.1482116 ##  1 5 6 7  =   0.4314737 V <- matrix(rnorm(36),ncol=4) jj <- c(    as.function(o)(V),    as.function(contract(o,V[,1,drop=TRUE]))(V[,-1]), # scalar    as.function(contract(o,V[,1:2]))(V[,-(1:2),drop=FALSE]),    as.function(contract(o,V[,1:3]))(V[,-(1:3),drop=FALSE]),    as.function(contract(o,V[,1:4],lose=FALSE))(V[,-(1:4),drop=FALSE]) ) print(jj) ## [1] -0.4992204 -0.4992204 -0.4992204 -0.4992204 -0.4992204 max(jj) - min(jj) # zero to numerical precision ## [1] 2.775558e-16 contract(o,V) ## [1] -0.4992204 contract(o,V,lose=FALSE) ## An alternating linear map from V^0 to R with V=R^0: ##             val ##   =  -0.4992204 o <- as.kform(1:5) V <- matrix(rnorm(25),5,5) LHS <- det(V) RHS <- contract(o,V) c(LHS=LHS,RHS=RHS,diff=LHS-RHS) ##          LHS          RHS         diff  ## 6.355108e+00 6.355108e+00 1.776357e-15"},{"path":"https://robinhankin.github.io/stokes/articles/contract.html","id":"contraction-from-first-principles","dir":"Articles","previous_headings":"","what":"Contraction from first principles","title":"Functions `contract()` and `contract_elementary()` in the `stokes` package","text":"Suppose wish contract \\phi=dx^{i_1}\\wedge\\cdots\\wedge dx^{i_k} vector \\mathbf{v}=(v_1\\mathbf{e}_1,\\ldots,v_k\\mathbf{e}_k). Thus seek \\phi_\\mathbf{v} \\phi_\\mathbf{v}\\left(\\mathbf{v}_1,\\ldots,\\mathbf{v}_{k-1}\\right) = dx^{i_1}\\wedge\\cdots\\wedge dx^{i_k}\\left(\\mathbf{v},\\mathbf{v}_1,\\ldots\\mathbf{v}_{k-1}\\right). Writing \\mathbf{v}=v_1\\mathbf{e}_1+\\cdots+\\mathbf{e}_k, \\begin{eqnarray} \\phi_\\mathbf{v}\\left(\\mathbf{v}_1,\\ldots,\\mathbf{v}_{k-1}\\right) &=& dx^{i_1}\\wedge\\cdots\\wedge dx^{i_k}\\left(\\mathbf{v},\\mathbf{v}_1,\\ldots\\mathbf{v}_{k-1}\\right)\\\\&=& dx^{i_1}\\wedge\\cdots\\wedge dx^{i_k}\\left(v_1\\mathbf{e}_1+\\cdots+v_k\\mathbf{e}_k,\\mathbf{v}_1,\\ldots\\mathbf{v}_{k-1}\\right)\\\\&=& v_1 dx^{i_1}\\wedge\\cdots\\wedge dx^{i_k}\\left(\\mathbf{e}_1,\\mathbf{v}_1,\\ldots,\\mathbf{v}_{k-1}\\right)+\\cdots+ v_k dx^{i_1}\\wedge\\cdots\\wedge dx^{i_k}\\left(\\mathbf{e}_k,\\mathbf{v}_1,\\ldots,\\mathbf{v}_{k-1}\\right). \\end{eqnarray} exploited linearity. evaluate easiest efficient express \\phi \\bigwedge_{j=1}^kdx^{i_j} cycle index j, use various properties wedge products: \\begin{eqnarray} dx^{i_1}\\wedge\\cdots\\wedge dx^{i_k} &=& (-1)^{j-1} dx^{i_j}\\wedge\\left(dx^{i_1}\\wedge\\cdots\\wedge\\widehat{dx^{i_j}}\\wedge\\cdots\\wedge dx^{-k}\\right)\\\\ &=& (-1)^{j-1} k\\operatorname{Alt}\\left(dx^{i_j}\\otimes\\left(dx^{i_1}\\wedge\\cdots\\wedge\\widehat{dx^{i_j}}\\wedge\\cdots\\wedge dx^{-k}\\right)\\right) \\end{eqnarray} (, hat indicates term’s omitted). , see l\\\\L\\longrightarrow\\phi=0 (L=\\left\\lbrace i_1,\\ldots i_k\\right\\rbrace index set \\phi), dx^p terms kill \\mathbf{e}_l. hand, l\\L \\begin{eqnarray} \\phi_{\\mathbf{e}_l}\\left(\\mathbf{v}_1,\\ldots,\\mathbf{v}_{k-1}\\right) &=& \\left(dx^{l}\\wedge\\left(dx^{i_1}\\wedge\\cdots\\wedge\\widehat{dx^{l}}\\wedge\\cdots\\wedge dx^{i_k}\\right)\\right)\\left(\\mathbf{e}_l,\\mathbf{v}_1,\\ldots,\\mathbf{v}_{k-1}\\right)\\\\ &=& (-1)^{l-1}k\\left(dx^{l}\\otimes\\left(dx^{i_1}\\wedge\\cdots\\wedge\\widehat{dx^{l}}\\wedge\\cdots\\wedge dx^{i_k}\\right)\\right)\\left(\\mathbf{e}_l,\\left(\\mathbf{v}_1,\\ldots,\\mathbf{v}_{k-1}\\right)\\right)\\\\ &=& (-1)^{l-1}k\\left(dx^{i_1}\\wedge\\cdots\\wedge\\widehat{dx^{l}}\\wedge\\cdots\\wedge dx^{i_k}\\right)\\left(\\mathbf{v}_1,\\ldots,\\mathbf{v}_{k-1}\\right) \\end{eqnarray}","code":""},{"path":"https://robinhankin.github.io/stokes/articles/contract.html","id":"worked-example-using-contract_elementary","dir":"Articles","previous_headings":"","what":"Worked example using contract_elementary()","title":"Functions `contract()` and `contract_elementary()` in the `stokes` package","text":"Function contract_elementary() bare-bones low-level -frills helper function returns \\phi_\\mathbf{v} \\phi elementary form form dx^{i_1}\\wedge\\cdots\\wedge dx^{i_k}. Suppose wish contract \\phi=dx^1\\wedge dx^2\\wedge dx^5 vector \\mathbf{v}=(1,2,10,11,71)^T. Thus seek \\phi_\\mathbf{v} \\phi_\\mathbf{v}\\left(\\mathbf{v}_1,\\mathbf{v}_2 \\right)=dx^1\\wedge dx^2\\wedge dx^5\\left(\\mathbf{v},\\mathbf{v}_1,\\mathbf{v}_2\\right). Writing \\mathbf{v}=v_1\\mathbf{e}_1+\\cdots+v_5\\mathbf{e}_5 \\begin{eqnarray} \\phi_\\mathbf{v}\\left(\\mathbf{v}_1,\\mathbf{v}_2 \\right)                         &=& dx^1\\wedge dx^2\\wedge dx^5\\left(\\mathbf{v},\\mathbf{v}_1,\\mathbf{v}_2\\right)\\\\  &=& dx^1\\wedge dx^2\\wedge dx^5\\left(v_1\\mathbf{e}_1+\\cdots+v_5\\mathbf{e}_5,\\mathbf{v}_1,\\mathbf{v}_2\\right)\\\\&=& v_1 dx^1\\wedge dx^2\\wedge dx^5\\left(\\mathbf{e}_1,\\mathbf{v}_1,\\mathbf{v}_2\\right)+ v_2 dx^1\\wedge dx^2\\wedge dx^5\\left(\\mathbf{e}_2,\\mathbf{v}_1,\\mathbf{v}_2\\right)\\\\ &{}&\\qquad +v_3dx^1\\wedge dx^2\\wedge dx^5\\left(\\mathbf{e}_3,\\mathbf{v}_1,\\mathbf{v}_2\\right)+ v_4 dx^1\\wedge dx^2\\wedge dx^5\\left(\\mathbf{e}_4,\\mathbf{v}_1,\\mathbf{v}_2\\right)\\\\ &{}&\\qquad\\qquad +v_5dx^1\\wedge dx^2\\wedge dx^5\\left(\\mathbf{e}_5,\\mathbf{v}_1,\\mathbf{v}_2\\right)\\\\&=& v_1 dx^2\\wedge dx^5\\left(\\mathbf{v}_1,\\mathbf{v}_2\\right)- v_2 dx^1\\wedge dx^5\\left(\\mathbf{v}_1,\\mathbf{v}_2\\right)+0+0+ v_5 dx^1\\wedge dx^2\\left(\\mathbf{v}_1,\\mathbf{v}_2\\right) \\end{eqnarray} (, zero terms vectors \\mathbf{e}_3 \\mathbf{e}_4 killed dx^1\\wedge dx^2\\wedge dx^5). can see way evaluate contraction go terms \\phi [, dx^1, dx^2, dx^5] turn, sum resulting expressions: performed succinctly contract_elementary():","code":"o <- c(1,2,5) v <- c(1,2,10,11,71) ( (-1)^(1+1) * as.kform(o[-1])*v[o[1]] +  (-1)^(2+1) * as.kform(o[-2])*v[o[2]] + (-1)^(3+1) * as.kform(o[-3])*v[o[3]] ) ## An alternating linear map from V^2 to R with V=R^5: ##          val ##  1 5  =   -2 ##  2 5  =    1 ##  1 2  =   71 contract_elementary(o,v) ## An alternating linear map from V^2 to R with V=R^5: ##          val ##  1 5  =   -2 ##  2 5  =    1 ##  1 2  =   71"},{"path":"https://robinhankin.github.io/stokes/articles/contract.html","id":"the-meat-of-contract","dir":"Articles","previous_headings":"","what":"The “meat” of contract()","title":"Functions `contract()` and `contract_elementary()` in the `stokes` package","text":"Given vector v, kform object K, meat contract() show operation simple nontrivial arguments. inside bit see two-element list, one elementary term K. use base R’s Map() function multiply one appropriate coefficient: finally use Reduce() sum terms: However, might conceptually easier use magrittr pipes give equivalent definition: Well might clearer Hadley frankly YMMV.","code":"Reduce(\"+\", Map(\"*\", apply(index(K), 1, contract_elementary, v), elements(coeffs(K)))) (K <- as.kform(spray(matrix(c(1,2,3,6,2,4,5,7),2,4,byrow=TRUE),1:2))) ## An alternating linear map from V^4 to R with V=R^7: ##              val ##  2 4 5 7  =    2 ##  1 2 3 6  =    1 v <- 1:7 apply(index(K), 1, contract_elementary, v) ## [[1]] ## An alternating linear map from V^3 to R with V=R^7: ##            val ##  2 4 7  =    5 ##  4 5 7  =    2 ##  2 5 7  =   -4 ##  2 4 5  =   -7 ##  ## [[2]] ## An alternating linear map from V^3 to R with V=R^6: ##            val ##  1 2 6  =    3 ##  2 3 6  =    1 ##  1 3 6  =   -2 ##  1 2 3  =   -6 Map(\"*\", apply(index(K), 1, contract_elementary, v), elements(coeffs(K))) ## [[1]] ## An alternating linear map from V^3 to R with V=R^7: ##            val ##  2 4 5  =  -14 ##  2 5 7  =   -8 ##  4 5 7  =    4 ##  2 4 7  =   10 ##  ## [[2]] ## An alternating linear map from V^3 to R with V=R^6: ##            val ##  1 2 3  =   -6 ##  1 3 6  =   -2 ##  2 3 6  =    1 ##  1 2 6  =    3 Reduce(\"+\",Map(\"*\", apply(index(K), 1, contract_elementary, v), elements(coeffs(K)))) ## An alternating linear map from V^3 to R with V=R^7: ##            val ##  2 4 7  =   10 ##  4 5 7  =    4 ##  2 5 7  =   -8 ##  1 2 3  =   -6 ##  2 4 5  =  -14 ##  1 3 6  =   -2 ##  2 3 6  =    1 ##  1 2 6  =    3 K                                %>% index                              %>% apply(1,contract_elementary,v)       %>% Map(\"*\", ., K %>% coeffs %>% elements) %>% Reduce(\"+\",.) ## An alternating linear map from V^3 to R with V=R^7: ##            val ##  2 4 7  =   10 ##  4 5 7  =    4 ##  2 5 7  =   -8 ##  1 2 3  =   -6 ##  2 4 5  =  -14 ##  1 3 6  =   -2 ##  2 3 6  =    1 ##  1 2 6  =    3"},{"path":[]},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/dx.html","id":"elementary-forms-and-the-print-method","dir":"Articles","previous_headings":"","what":"Elementary forms and the print method","title":"Objects `dx`, `dy`, and `dz` in the `stokes` package","text":"print method configurable can display kforms symbolic form. working dx dy dz may set option kform_symbolic_print dx: results calculations natural: However, setting can confusing work \\mathrm{d}x^,>3, print method runs alphabet: , see use NA defined symbol.","code":"options(kform_symbolic_print = 'dx') dx ## An alternating linear map from V^1 to R with V=R^1: ##  + dx dx^dy + 56*dy^dz ## An alternating linear map from V^2 to R with V=R^3: ##  + dx^dy +56 dy^dz rform() ## An alternating linear map from V^3 to R with V=R^7: ##  +6 dy^dNA^dNA +5 dy^dNA^dNA -9 dNA^dNA^dNA +4 dx^dz^dNA +7 dx^dNA^dNA -3 dy^dz^dNA -8 dx^dNA^dNA +2 dx^dy^dNA + dx^dNA^dNA"},{"path":"https://robinhankin.github.io/stokes/articles/dx.html","id":"the-hodge-dual","dir":"Articles","previous_headings":"Elementary forms and the print method","what":"The Hodge dual","title":"Objects `dx`, `dy`, and `dz` in the `stokes` package","text":"Function hodge() returns Hodge dual: Note calling hodge(dx) can confusing: returns scalar dx interpreted one-form one-dimensional space, scalar form. One usually wants result three dimensions: discussed dovs vignette.","code":"hodge(dx^dy + 13*dy^dz) ## An alternating linear map from V^1 to R with V=R^3: ##  +13 dx + dz hodge(dx) ## [1] 1 hodge(dx,3) ## An alternating linear map from V^2 to R with V=R^3: ##  + dy^dz"},{"path":"https://robinhankin.github.io/stokes/articles/dx.html","id":"other-ways-to-create-the-elementary-one-forms","dir":"Articles","previous_headings":"Elementary forms and the print method","what":"Other ways to create the elementary one-forms","title":"Objects `dx`, `dy`, and `dz` in the `stokes` package","text":"possible create objects using package idiom:","code":"d(1) == dx ## [1] TRUE"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/dx.html","id":"package-dataset","dir":"Articles","previous_headings":"Elementary forms and the print method > Basis vectors","what":"Package dataset","title":"Objects `dx`, `dy`, and `dz` in the `stokes` package","text":"Following lines create dx.rda, residing data/ directory package.","code":"save(dx,dy,dz,file=\"dx.rda\")"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/ex.html","id":"package-dataset","dir":"Articles","previous_headings":"","what":"Package dataset","title":"Objects `ex`, `ey`, and `ez` in the `stokes` package","text":"Following lines create exeyez.rda, residing data/ directory package.","code":"save(ex,ey,ez,file=\"exeyez.rda\")"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/hodge.html","id":"the-hodge-dual-on-basis-elements-of-lambdakv","dir":"Articles","previous_headings":"","what":"The Hodge dual on basis elements of \\Lambda^k(V)","title":"The `hodge()` function in the `stokes` package","text":"start demonstrating hodge() basis elements \\Lambda^k(V). Recall \\left\\lbrace e_1,\\ldots,e_n\\right\\rbrace basis vector space V=\\mathbb{R}^n, \\left\\lbrace\\omega_1,\\ldots,\\omega_k\\right\\rbrace basis \\Lambda^1(V), \\omega_i(e_j)=\\delta_{ij}. basis \\Lambda^k(V) given set \\bigcup_{1\\leqslant i_1 < \\cdots < i_k\\leqslant n} \\bigwedge_{j=1}^k\\omega_{i_j} = \\left\\lbrace \\left.\\omega_{i_1}\\wedge\\cdots\\wedge\\omega_{i_k} \\right|1\\leqslant i_1 < \\cdots < i_k\\leqslant n \\right\\rbrace. means basis elements things like \\omega_2\\wedge\\omega_6\\wedge\\omega_7. f V=\\mathbb{R}^9, \\star\\omega_2\\wedge\\omega_6\\wedge\\omega_7? See \\star index entries 1-9 except 2,6,7 (). (numerical) sign negative permutation negative (permutational) sign. can verify using permutations package: see sign permutation negative. succinct idiom second argument hodge() needed largest index i_k first argument less n; default value indeed n. example , 7: see result V=\\mathbb{R}^7.","code":"(a <- d(2) ^ d(6) ^ d(7)) ## An alternating linear map from V^3 to R with V=R^7: ##            val ##  2 6 7  =    1 hodge(a,9) ## An alternating linear map from V^6 to R with V=R^9: ##                  val ##  1 3 4 5 8 9  =   -1 p <- c(2,6,7,  1,3,4,5,8,9) (pw <- as.word(p)) ## [1] (1264)(375) ## [coerced from word form] print_word(pw) ##     1 2 3 4 5 6 7 8 9 ## [1] 2 6 7 1 3 4 5 . . sgn(pw) ## [1] -1 hodge(d(c(2,6,7)),9) ## An alternating linear map from V^6 to R with V=R^9: ##                  val ##  1 3 4 5 8 9  =   -1 hodge(d(c(2,6,7))) ## An alternating linear map from V^4 to R with V=R^5: ##              val ##  1 3 4 5  =   -1"},{"path":"https://robinhankin.github.io/stokes/articles/hodge.html","id":"more-complicated-examples","dir":"Articles","previous_headings":"","what":"More complicated examples","title":"The `hodge()` function in the `stokes` package","text":"hodge operator linear interesting verify . verify fundamental relation holds direct inspection: showing agreement (, use function volume() lieu calculating permutation’s sign explicitly. See volume vignette details). may work formally defining function returns TRUE left right hand sides match call random k-forms: even","code":"(o <- rform()) ## An alternating linear map from V^3 to R with V=R^7: ##            val ##  2 6 7  =    6 ##  2 5 7  =    5 ##  5 6 7  =   -9 ##  1 3 7  =    4 ##  1 5 7  =    7 ##  2 3 5  =   -3 ##  1 5 6  =   -8 ##  1 2 7  =    2 ##  1 4 6  =    1 hodge(o) ## An alternating linear map from V^4 to R with V=R^7: ##              val ##  2 3 5 7  =   -1 ##  3 4 5 6  =    2 ##  2 3 4 7  =   -8 ##  1 4 6 7  =   -3 ##  2 3 4 6  =   -7 ##  2 4 5 6  =   -4 ##  1 2 3 4  =   -9 ##  1 3 4 6  =    5 ##  1 3 4 5  =   -6 o ^ hodge(o) ## An alternating linear map from V^7 to R with V=R^7: ##                    val ##  1 2 3 4 5 6 7  =  285 kinner(o,o)*volume(dovs(o)) ## An alternating linear map from V^7 to R with V=R^7: ##                    val ##  1 2 3 4 5 6 7  =  285 diff <- function(a,b){a^hodge(b) ==  kinner(a,b)*volume(dovs(a))} diff(rform(),rform()) ## [1] TRUE all(replicate(10,diff(rform(),rform()))) ## [1] TRUE"},{"path":"https://robinhankin.github.io/stokes/articles/hodge.html","id":"small-dimensional-vector-spaces","dir":"Articles","previous_headings":"","what":"Small-dimensional vector spaces","title":"The `hodge()` function in the `stokes` package","text":"can work three dimensions case three linearly independent 1-forms: dx, dy, dz. work system better use dx print method: discussed dovs vignette.","code":"options(kform_symbolic_print = \"dx\") hodge(dx,3) ## An alternating linear map from V^2 to R with V=R^3: ##  + dy^dz"},{"path":"https://robinhankin.github.io/stokes/articles/hodge.html","id":"vector-cross-product-identities","dir":"Articles","previous_headings":"","what":"Vector cross product identities","title":"The `hodge()` function in the `stokes` package","text":"three dimensional vector cross product \\mathbf{u}\\times\\mathbf{v}=\\det\\begin{pmatrix} & j & k \\\\ u_1&u_2&u_3\\\\ v_1&v_2&v_3 \\end{pmatrix} standard part elementary vector calculus. package idiom follows: revealing formal definition cross product \\mathbf{u}\\times\\mathbf{v}=\\star{\\left(\\mathbf{u}\\wedge\\mathbf{v}\\right)}. several elementary identities satisfied cross product: \\begin{aligned} \\mathbf{u}\\times(\\mathbf{v}\\times\\mathbf{w}) &= \\mathbf{v}(\\mathbf{w}\\cdot\\mathbf{u})-\\mathbf{w}(\\mathbf{u}\\cdot\\mathbf{v})\\\\ (\\mathbf{u}\\times\\mathbf{v})\\times\\mathbf{w} &= \\mathbf{v}(\\mathbf{w}\\cdot\\mathbf{u})-\\mathbf{u}(\\mathbf{v}\\cdot\\mathbf{w})\\\\ (\\mathbf{u}\\times\\mathbf{v})\\times(\\mathbf{u}\\times\\mathbf{w}) &= (\\mathbf{u}\\cdot(\\mathbf{v}\\times\\mathbf{w}))\\mathbf{u}  \\\\ (\\mathbf{u}\\times\\mathbf{v})\\cdot(\\mathbf{w}\\times\\mathbf{x})  &= (\\mathbf{u}\\cdot\\mathbf{w})(\\mathbf{v}\\cdot\\mathbf{x}) -                                                                   (\\mathbf{u}\\cdot\\mathbf{x})(\\mathbf{v}\\cdot\\mathbf{w}) \\end{aligned} may verify four together: , note use hodge operator define triple vector cross products. example \\mathbf{u}\\times\\left(\\mathbf{v}\\times\\mathbf{w}\\right)= \\star\\left(\\mathbf{u}\\wedge\\star\\left(\\mathbf{v}\\wedge\\mathbf{w}\\right)\\right).","code":"vcp3 ## function (u, v)  ## { ##     hodge(as.1form(u)^as.1form(v)) ## } u <- c(1,4,2) v <- c(2,1,5) w <- c(1,-3,2) x <- c(-6,5,7) c(   hodge(as.1form(u) ^ vcp3(v,w))        == as.1form(v*sum(w*u) - w*sum(u*v)),   hodge(vcp3(u,v) ^ as.1form(w))        == as.1form(v*sum(w*u) - u*sum(v*w)),   as.1form(as.function(vcp3(v,w))(u)*u) == hodge(vcp3(u,v) ^ vcp3(u,w))     ,   hodge(hodge(vcp3(u,v)) ^ vcp3(w,x))   == sum(u*w)*sum(v*x) - sum(u*x)*sum(v*w) ) ## [1] TRUE TRUE TRUE TRUE"},{"path":"https://robinhankin.github.io/stokes/articles/hodge.html","id":"non-positive-definite-metrics","dir":"Articles","previous_headings":"","what":"Non positive-definite metrics","title":"The `hodge()` function in the `stokes` package","text":"inner product \\left\\langle\\alpha,\\beta\\right\\rangle may generalized defining decomposable vectors \\alpha=\\alpha_1\\wedge\\cdots\\wedge\\alpha_k \\beta=\\beta_1\\wedge\\cdots\\wedge\\beta_k \\left\\langle\\alpha,\\beta\\right\\rangle= \\det\\left(\\left\\langle\\alpha_i,\\beta_j\\right\\rangle_{,j}\\right) \\left\\langle\\alpha_i,\\beta_j\\right\\rangle=\\pm\\delta_{ij} inner product \\Lambda^1(V) [inner product given kinner()]. resulting Hodge star operator implemented package one can specify metric. example, consider Minkowski metric -1,1,1,1.","code":""},{"path":"https://robinhankin.github.io/stokes/articles/hodge.html","id":"print-methods-for-the-minkowski-metric","dir":"Articles","previous_headings":"Non positive-definite metrics","what":"Print methods for the Minkowski metric","title":"The `hodge()` function in the `stokes` package","text":"standard print method particularly suitable working Minkowski metric: see unhelpful representation. work 2-forms relativistic physics, often preferable use bespoke print method usetxyz:","code":"options(kform_symbolic_print = NULL)  # default print method (o <- kform_general(4,2,1:6)) ## An alternating linear map from V^2 to R with V=R^4: ##          val ##  3 4  =    6 ##  2 4  =    5 ##  1 4  =    4 ##  2 3  =    3 ##  1 3  =    2 ##  1 2  =    1 options(kform_symbolic_print = \"txyz\") o ## An alternating linear map from V^2 to R with V=R^4: ##  +6 dy^dz +5 dx^dz +4 dt^dz +3 dx^dy +2 dt^dy + dt^dx"},{"path":"https://robinhankin.github.io/stokes/articles/hodge.html","id":"specifying-the-minkowski-metric","dir":"Articles","previous_headings":"Non positive-definite metrics","what":"Specifying the Minkowski metric","title":"The `hodge()` function in the `stokes` package","text":"Function hodge() takes g argument specify metric:","code":"hodge(o) ## An alternating linear map from V^2 to R with V=R^4: ##  + dy^dz -2 dx^dz +3 dt^dz +4 dx^dy -5 dt^dy +6 dt^dx hodge(o,g=c(-1,1,1,1)) ## An alternating linear map from V^2 to R with V=R^4: ##  - dy^dz +2 dx^dz +3 dt^dz -4 dx^dy -5 dt^dy +6 dt^dx hodge(o)-hodge(o,g=c(-1,1,1,1)) ## An alternating linear map from V^2 to R with V=R^4: ##  +8 dx^dy -4 dx^dz +2 dy^dz"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/inner.html","id":"alternating-forms","dir":"Articles","previous_headings":"","what":"Alternating forms","title":"The `inner()` function in the `stokes` package","text":"inner product antisymmetric matrix alternating: see \\mathbf{x}^TM\\mathbf{y} = -\\mathbf{y}^TM\\mathbf{x} M antisymmetric.","code":"jj <- matrix(rpois(49,lambda=3.2),7,7) M <- jj-t(jj) # M is antisymmetric f <- as.function(inner(M)) LHS <- f(V) RHS <- -f(V[,2:1])   # NB negative as we are checking for an alternating form c(LHS=LHS,RHS=RHS,diff=LHS-RHS) ##      LHS      RHS     diff  ## 19.50013 19.50013  0.00000"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/kinner.html","id":"some-simple-examples","dir":"Articles","previous_headings":"","what":"Some simple examples","title":"The `kinner()` function in the `stokes` package","text":"Michael Penn uses metric \\begin{blockarray}{crrrr} & dt & dx & dy & dz\\\\ \\begin{block}{c[rrrr]} dt &  1 &  0 &  0 & 0 \\bigstrut[t] \\\\ dx &  0 & -1 &  0 & 0 \\\\ dy &  0 &  0 & -1 & 0 \\bigstrut[b]\\\\ dz &  0 &  0 &  0 &-1 \\bigstrut[b]\\\\ \\end{block} \\end{blockarray} shows \\begin{blockarray}{crrrrrrr} & dt\\wedge dx & dt\\wedge dy & dt\\wedge dz & dx\\wedge dy & dx\\wedge dz& dy\\wedge dz\\\\ \\begin{block}{c[rrrrrrr]} dt\\wedge dx & -1 &  0 &  0 &0&0&0&\\bigstrut[t] \\\\ dt\\wedge dy &  0 & -1 &  0 &0&0&0& \\\\ dt\\wedge dz &  0 &  0 & -1 &0&0&0&\\bigstrut[b]\\\\ dx\\wedge dy &  0 &  0 &  0 &1&0&0&\\bigstrut[b]\\\\ dx\\wedge dz &  0 &  0 &  0 &0&1&0&\\bigstrut[b]\\\\ dy\\wedge dz &  0 &  0 &  0 &0&0&1&\\bigstrut[b]\\\\ \\end{block} \\end{blockarray} , example, \\left\\langle dt\\wedge dx,dt\\wedge dx\\right\\rangle=-1 \\left\\langle dt\\wedge dx,dt\\wedge dy\\right\\rangle=0. can reproduce relatively easily package follows. First need -write default values dx, dy, dz (defined three dimensions) define dt dx dy dz: Slightly slicker:","code":"dt <- d(1) dx <- d(2) dy <- d(3) dz <- d(4) p <- c(\"dt^dx\",\"dt^dy\",\"dt^dz\",\"dx^dy\",\"dx^dz\",\"dy^dz\")  mink <- diag(c(1,-1,-1,-1)) # Minkowski metric  M <- matrix(NA,6,6) rownames(M) <- p colnames(M) <- p  do <- function(x){eval(parse(text=x))} for(i in seq_len(6)){   for(j in seq_len(6)){     M[i,j] <- kinner(do(p[i]),do(p[j]),M=mink)   } }    M ##       dt^dx dt^dy dt^dz dx^dy dx^dz dy^dz ## dt^dx    -1     0     0     0     0     0 ## dt^dy     0    -1     0     0     0     0 ## dt^dz     0     0    -1     0     0     0 ## dx^dy     0     0     0     1     0     0 ## dx^dz     0     0     0     0     1     0 ## dy^dz     0     0     0     0     0     1 outer(p,p,Vectorize(function(i,j){kinner(do(i),do(j),M=mink)})) ##      [,1] [,2] [,3] [,4] [,5] [,6] ## [1,]   -1    0    0    0    0    0 ## [2,]    0   -1    0    0    0    0 ## [3,]    0    0   -1    0    0    0 ## [4,]    0    0    0    1    0    0 ## [5,]    0    0    0    0    1    0 ## [6,]    0    0    0    0    0    1"},{"path":"https://robinhankin.github.io/stokes/articles/kinner.html","id":"tidyup","dir":"Articles","previous_headings":"","what":"Tidyup","title":"The `kinner()` function in the `stokes` package","text":"important remove dt, dx, dt, dx created interfere vignettes:","code":"rm(dt,dx,dy,dz)"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"the-stokes-package","dir":"Articles","previous_headings":"","what":"The stokes package","title":"Exterior calculus with R","text":"cite stokes package publications please use (Hankin 2022c). Ordinary differential calculus may formalized generalized arbitrary-dimensional oriented manifolds using exterior calculus. show stokes package furnishes functionality working exterior calculus, provide numerical verification number theorems. Notation follows Spivak (1965), Hubbard Hubbard (2015). Recall k-tensor multilinear map S\\colon V^k\\longrightarrow\\mathbb{R}, V=\\mathbb{R}^n considered vector space; Spivak denotes space multilinear maps \\mathcal{J}^k(V). Formally, multilinearity means S{\\left(v_1,\\ldots,av_i,\\ldots,v_k\\right)} = \\cdot S{\\left(v_1,\\ldots,v_i,\\ldots,v_k\\right)} S{\\left(v_1,\\ldots,v_i+{v_i}',\\ldots,v_k\\right)}=S{\\left(v_1,\\ldots,v_i,\\ldots,x_v\\right)}+ S{\\left(v_1,\\ldots,{v_i}',\\ldots,v_k\\right)}. v_i\\V. S\\\\mathcal{J}^k(V) T\\\\mathcal{J}^l(V), may define S\\otimes T\\\\mathcal{J}^{k+l}(V) S\\otimes T{\\left(v_1,\\ldots,v_k,v_{k+1},\\ldots,v_{k+l}\\right)}= S{\\left(v_1,\\ldots,v_k\\right)}\\cdot T{\\left(v_1,\\ldots,v_l\\right)}. Spivak observes \\mathcal{J}^k(V) spanned n^k products form \\phi_{i_1}\\otimes\\phi_{i_2}\\otimes\\cdots\\otimes\\phi_{i_k}\\qquad 1\\leq i_i,i_2,\\ldots,i_k\\leq n v_1,\\ldots,v_k basis V \\phi_i{\\left(v_j\\right)}=\\delta_{ij}; can therefore write S=\\sum_{1\\leq i_1,\\ldots,i_k\\leq n} a_{i_1\\ldots i_k} \\phi_{i_1}\\otimes\\cdots\\otimes\\phi_{i_k}. space spanned products natural representation R array dimensions n\\times\\cdots\\times n=n^k. array, element [i_1,i_2,...,i_k] coefficient \\phi_{i_1}\\otimes\\ldots\\otimes\\phi_{i_k}. However, efficient conceptually cleaner consider sparse array, implemented spray package. consider case n=5,k=4, multilinear maps \\left(\\mathbb{R}^5\\right)^4 \\mathbb{R}. , test algebraic identities R using idiom furnished stokes package. example define S=1.5\\phi_5\\otimes\\phi_1\\otimes\\phi_1\\otimes\\phi_1+2.5\\phi_1\\otimes\\phi_1\\otimes\\phi_2\\otimes\\phi_3+3.5\\phi_1\\otimes\\phi_3\\otimes\\phi_4\\otimes\\phi_2 using matrix three rows, one per term, whose rows correspond term’s tensor products \\phi’s. first load stokes package: idiom straightforward: Observe , stored array size n^k, S 5^4=625 elements, three zero. S 4-tensor, mapping V^4 \\mathbb{R}, V=\\mathbb{R}^5. S=1.5\\phi_5\\otimes\\phi_1\\otimes\\phi_1\\otimes\\phi_1+2.5\\phi_1\\otimes\\phi_1\\otimes\\phi_2\\otimes\\phi_3+3.5\\phi_1\\otimes\\phi_3\\otimes\\phi_4\\otimes\\phi_2. Note implementations row order object S differ M; phenomenon due underlying C implementation using STL map class; see disordR package (Hankin 2022a) discussed detail mvp package (Hankin 2022b).","code":"library(\"stokes\") k <- 4 n <- 5 M <- matrix(c(5,1,1,1, 1,1,2,3, 1,3,4,2),3,4,byrow=TRUE) M ##      [,1] [,2] [,3] [,4] ## [1,]    5    1    1    1 ## [2,]    1    1    2    3 ## [3,]    1    3    4    2 S <- as.ktensor(M,coeffs= 0.5 + 1:3) S ## A linear map from V^4 to R with V=R^5: ##              val ##  1 3 4 2  =  3.5 ##  1 1 2 3  =  2.5 ##  5 1 1 1  =  1.5"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"package-idiom-for-evaluation-of-a-tensor","dir":"Articles","previous_headings":"The stokes package","what":"Package idiom for evaluation of a tensor","title":"Exterior calculus with R","text":"First, define E random point V^k terms matrix: Recall n=5, k=4, E\\\\left(\\mathbb{R}^5\\right)^4. can evaluate S E follows:","code":"set.seed(0) (E <- matrix(rnorm(n*k),n,k))   # A random point in V^k ##            [,1]         [,2]       [,3]       [,4] ## [1,]  1.2629543 -1.539950042  0.7635935 -0.4115108 ## [2,] -0.3262334 -0.928567035 -0.7990092  0.2522234 ## [3,]  1.3297993 -0.294720447 -1.1476570 -0.8919211 ## [4,]  1.2724293 -0.005767173 -0.2894616  0.4356833 ## [5,]  0.4146414  2.404653389 -0.2992151 -1.2375384 f <- as.function(S) f(E) ## [1] -3.068997"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"vector-space-structure-of-tensors","dir":"Articles","previous_headings":"The stokes package","what":"Vector space structure of tensors","title":"Exterior calculus with R","text":"Tensors natural vector space structure; may added subtracted, multiplied scalar, vector space. , define new tensor S_1 work 2S-3S_1: may verify tensors linear using package idiom: (, identical numerical precision).","code":"S1 <- as.ktensor(1+diag(4),1:4) 2*S-3*S1 ## A linear map from V^4 to R with V=R^5: ##              val ##  1 3 4 2  =    7 ##  1 1 2 3  =    5 ##  5 1 1 1  =    3 ##  1 1 1 2  =  -12 ##  1 1 2 1  =   -9 ##  1 2 1 1  =   -6 ##  2 1 1 1  =   -3 LHS <- as.function(2*S-3*S1)(E) RHS <- 2*as.function(S)(E) -3*as.function(S1)(E) c(lhs=LHS,rhs=RHS,diff=LHS-RHS) ##           lhs           rhs          diff  ##  2.374816e+00  2.374816e+00 -4.440892e-16"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"numerical-verification-of-multilinearity-in-the-package","dir":"Articles","previous_headings":"The stokes package","what":"Numerical verification of multilinearity in the package","title":"Exterior calculus with R","text":"Testing multilinearity straightforward package. , need define three matrices E1,E2,E3 corresponding points \\left(\\mathbb{R}^5\\right)^4 identical except one column. E3, column linear combination corresponding column E2 E3: can verify multilinearity S coercing function applied E1, E2, E3: (, identical numerical precision). Note equivalent linearity V^{nk}:","code":"E1 <- E E2 <- E E3 <- E  x1 <- rnorm(n) x2 <- rnorm(n) r1 <- rnorm(1) r2 <- rnorm(1)  E1[,2] <- x1 E2[,2] <- x2 E3[,2] <- r1*x1 + r2*x2 f <- as.function(S) LHS <- r1*f(E1) + r2*f(E2) RHS <- f(E3) c(lhs=LHS,rhs=RHS,diff=LHS-RHS) ##        lhs        rhs       diff  ## -0.5640577 -0.5640577  0.0000000 E1 <- matrix(rnorm(n*k),n,k) E2 <- matrix(rnorm(n*k),n,k) LHS <- f(r1*E1+r2*E2) RHS <- r1*f(E1)+r2*f(E2) c(lhs=LHS,rhs=RHS,diff=LHS-RHS) ##        lhs        rhs       diff  ##  0.1731245  0.3074186 -0.1342941"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"tensor-product-of-general-tensors","dir":"Articles","previous_headings":"The stokes package","what":"Tensor product of general tensors","title":"Exterior calculus with R","text":"Given two k-tensor objects S,T can form tensor product S\\otimes T, defined S\\otimes T{\\left(v_1,\\ldots,v_k,v_{k+1},\\ldots, v_{k+l}\\right)}=   S{\\left(v_1,\\ldots v_k\\right)} \\cdot T{\\left(v_{k+1},\\ldots   v_{k+l}\\right)} calculate tensor product two tensors S1,S2 defined follows: R idiom S1\\otimes S2 tensorprod(), %X%: , example: (, identical numerical precision).","code":"(S1 <- ktensor(spray(cbind(1:3,2:4),1:3))) ## A linear map from V^2 to R with V=R^4: ##          val ##  3 4  =    3 ##  2 3  =    2 ##  1 2  =    1 (S2 <- as.ktensor(matrix(1:6,2,3))) ## A linear map from V^3 to R with V=R^6: ##            val ##  2 4 6  =    1 ##  1 3 5  =    1 tensorprod(S1,S2) ## A linear map from V^5 to R with V=R^6: ##                val ##  1 2 1 3 5  =    1 ##  3 4 1 3 5  =    3 ##  1 2 2 4 6  =    1 ##  2 3 2 4 6  =    2 ##  2 3 1 3 5  =    2 ##  3 4 2 4 6  =    3 E <- matrix(rnorm(30),6,5) LHS <- as.function(tensorprod(S1,S2))(E) RHS <- as.function(S1)(E[,1:2]) * as.function(S2)(E[,3:5]) c(lhs=LHS,rhs=RHS,diff=LHS-RHS) ##       lhs       rhs      diff  ## -1.048329 -1.048329  0.000000"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"alternating-forms","dir":"Articles","previous_headings":"","what":"Alternating forms","title":"Exterior calculus with R","text":"alternating form multilinear map T satisfying T{\\left(v_1,\\ldots,v_i,\\ldots,v_j,\\ldots,v_k\\right)}=     -T{\\left(v_1,\\ldots,v_j,\\ldots,v_i,\\ldots,v_k\\right)} (, equivalently, T{\\left(v_1,\\ldots,v_i,\\ldots,v_i,\\ldots,v_k\\right)}= 0). write \\Lambda^k(V) space alternating multilinear maps V^k \\mathbb{R}. Spivak gives \\operatorname{Alt}\\colon\\mathcal{J}^k(V)\\longrightarrow\\Lambda^k(V) defined \\operatorname{Alt}(T)\\left(v_1,\\ldots,v_k\\right)=     \\frac{1}{k!}\\sum_{\\sigma\\S_k}\\operatorname{sgn}(\\sigma)\\cdot     T{\\left(v_{\\sigma(1)},\\ldots,v_{\\sigma(k)}\\right)} sum ranges permutations \\left[n\\right]=\\left\\{1,2,\\ldots,n\\right\\} \\operatorname{sgn}(\\sigma)\\\\pm 1 sign permutation. T\\\\mathcal{J}^k(V) \\omega\\\\Lambda^k(V), straightforward prove \\operatorname{Alt}(T)\\\\Lambda^k(V), \\operatorname{Alt}\\left(\\operatorname{Alt}\\left(T\\right)\\right)=\\operatorname{Alt}\\left(T\\right), \\operatorname{Alt}\\left(\\omega\\right)=\\omega. stokes package, effected Alt() function: Verifying S1 fact alternating straightforward: However, can see form alternating tensors (called k-forms) inefficient highly redundant: example 1 2 term 2 1 term (coefficients equal opposite). example k=2 general potentially k! essentially repeated terms collectively require single coefficient. package provides kform objects inherently alternating using efficient representation; described using wedge products discussed next.","code":"S1 ## A linear map from V^2 to R with V=R^4: ##          val ##  3 4  =    3 ##  2 3  =    2 ##  1 2  =    1 Alt(S1) ## A linear map from V^2 to R with V=R^4: ##           val ##  4 3  =  -1.5 ##  3 2  =  -1.0 ##  2 3  =   1.0 ##  3 4  =   1.5 ##  2 1  =  -0.5 ##  1 2  =   0.5 E <- matrix(rnorm(8),4,2) Erev <- E[,2:1] as.function(Alt(S1))(E) + as.function(Alt(S1))(Erev)  # should be zero ## [1] 0"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"wedge-products-and-the-exterior-calculus","dir":"Articles","previous_headings":"Alternating forms","what":"Wedge products and the exterior calculus","title":"Exterior calculus with R","text":"section follows exposition Hubbard Hubbard, introduce exterior calculus starting discussion elementary forms, alternating forms particularly simple structure. example elementary form \\mathrm{d}x_1\\wedge\\mathrm{d}x_3 [treated indivisible entity], alternating multilinear map \\mathbb{R}^n\\times\\mathbb{R}^n \\mathbb{R} \\left( \\mathrm{d}x_1\\wedge\\mathrm{d}x_3 \\right)\\left( \\begin{pmatrix}a_1\\\\a_2\\\\a_3\\\\ \\vdots\\\\ a_n\\end{pmatrix}, \\begin{pmatrix}b_1\\\\b_3\\\\b_3\\\\ \\vdots\\\\ b_n\\end{pmatrix} \\right)=\\mathrm{det} \\begin{pmatrix} a_1 & b_1 \\\\ a_3 & b_3\\end{pmatrix} =a_1b_3-a_3b_1 alternating follows properties determinant. general course, \\mathrm{d}x_i\\wedge\\mathrm{d}x_j\\left( \\begin{pmatrix}a_1\\\\ \\vdots\\\\ a_n\\end{pmatrix}, \\begin{pmatrix}b_1\\\\ \\vdots\\\\ b_n\\end{pmatrix} \\right)=\\mathrm{det} \\begin{pmatrix} a_i & b_i \\\\ a_j & b_j\\end{pmatrix}. objects linear, possible consider sums elementary forms, d\\mathrm{x}_1\\wedge\\mathrm{d}x_2 + 3 \\mathrm{d}x_2\\wedge\\mathrm{d}x_3 \\left( \\mathrm{d}x_1\\wedge\\mathrm{d}x_2 + 3\\mathrm{d}x_2\\wedge\\mathrm{d}x_3 \\right)\\left( \\begin{pmatrix}a_1\\\\a_2\\\\ \\vdots\\\\ a_n\\end{pmatrix}, \\begin{pmatrix}b_1\\\\b_2\\\\ \\vdots\\\\ b_n\\end{pmatrix} \\right)=\\mathrm{det} \\begin{pmatrix} a_1 & b_1\\\\ a_2 & b_2\\end{pmatrix} +3\\mathrm{det} \\begin{pmatrix} a_2 & b_2\\\\ a_3 & b_3\\end{pmatrix} even K=\\mathrm{d}x_1\\wedge\\mathrm{d}x_2\\wedge\\mathrm{d}x_3 +5\\mathrm{d}x_1\\wedge\\mathrm{d}x_2\\wedge\\mathrm{d}x_4 linear map \\left(\\mathbb{R}^n\\right)^3 \\mathbb{R} \\left( \\mathrm{d}x_4\\wedge\\mathrm{d}x_2\\wedge\\mathrm{d}x_3 +5\\mathrm{d}x_1\\wedge\\mathrm{d}x_2\\wedge\\mathrm{d}x_4 \\right)\\left( \\begin{pmatrix}a_1\\\\a_2\\\\ \\vdots\\\\ a_n\\end{pmatrix}, \\begin{pmatrix}b_1\\\\b_2\\\\ \\vdots\\\\ b_n\\end{pmatrix}, \\begin{pmatrix}c_1\\\\c_2\\\\ \\vdots\\\\ c_n\\end{pmatrix} \\right)=\\mathrm{det} \\begin{pmatrix}     a_4 & b_4 & c_4\\\\     a_2 & b_2 & c_2\\\\     a_3 & b_3 & c_3 \\end{pmatrix} +5\\mathrm{det} \\begin{pmatrix}     a_1 & b_1 & c_1\\\\     a_2 & b_2 & c_2\\\\     a_4 & b_4 & c_4 \\end{pmatrix}. Defining K ready R idiom define matrix whose rows correspond differentials term: Function .kform() takes row M places elements increasing order; coefficient change sign permutation odd. Note order rows K immaterial indeed implementations appear different order: stokes package uses spray package, turn utilises STL map class C++.","code":"M <- matrix(c(4,2,3,1,4,2),2,3,byrow=TRUE) M ##      [,1] [,2] [,3] ## [1,]    4    2    3 ## [2,]    1    4    2 K <- as.kform(M,c(1,5)) K ## An alternating linear map from V^3 to R with V=R^4: ##            val ##  1 2 4  =   -5 ##  2 3 4  =    1"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"formal-definition-of-dx","dir":"Articles","previous_headings":"Alternating forms","what":"Formal definition of dx","title":"Exterior calculus with R","text":"previous section defined objects “\\mathrm{d}x_1\\wedge\\mathrm{d}x_6” single entity. define elementary form \\mathrm{d}x_i formally next section discuss wedge product \\wedge. elementary form \\mathrm{d}x_i simply map \\mathbb{R}^n \\mathbb{R} \\mathrm{d}x_i{\\left(x_1,x_2,\\ldots,x_n\\right)}=x_i. Observe \\mathrm{d}x_i alternating form, even though swap arguments (one). Package idiom creating elementary form appears somewhat cryptic first sight, consistent (easier understand package idiom creating complicated alternating forms, next section). Suppose wish work \\mathrm{d}x_3: Interpretation output obvious (easier understand output complicated alternating forms, next section), moment observe \\mathrm{d}x_3 indeed alternating form, mapping \\mathbb{R}^n \\mathbb{R} \\mathrm{d}x_3{\\left(x_1,x_2,\\ldots,x_n\\right)}=x_3. Thus, example: see \\mathrm{d}x_3 picks third element vector. linear sense may add subtract elementary forms:","code":"dx3 <- as.kform(matrix(3,1,1),1) options(kform_symbolic_print = NULL) # revert to default print method dx3 ## An alternating linear map from V^1 to R with V=R^3: ##        val ##  3  =    1 as.function(dx3)(c(14,15,16)) ## [1] 16 as.function(dx3)(c(14,15,16,17,18))  # idiom can deal with arbitrary vectors ## [1] 16 dx5 <- as.kform(matrix(5,1,1),1) as.function(dx3 + 2*dx5)(1:10)  # picks out element 3 + 2*element 5 ## [1] 13"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"formal-definition-of-wedge-product","dir":"Articles","previous_headings":"Alternating forms","what":"Formal definition of wedge product","title":"Exterior calculus with R","text":"wedge product maps two alternating forms another alternating form; given \\omega\\\\Lambda^k(V) \\eta\\\\Lambda^l(V), Spivak defines wedge product \\omega\\wedge\\eta\\\\Lambda^{k+l}(V) \\omega\\wedge\\eta={k+l\\choose k\\quad l}\\operatorname{Alt}(\\omega\\otimes\\eta) implemented package function wedge(), , idiomatically, ^: symbolic notation, K1 equal 7\\mathrm{d}x_1\\wedge\\mathrm{d}x_4\\wedge\\mathrm{d}x_6 -2\\mathrm{d}x_3\\wedge\\mathrm{d}x_4\\wedge\\mathrm{d}x_5. K2 \\mathrm{d}x_1\\wedge\\mathrm{d}x_3+ 2\\mathrm{d}x_2\\wedge\\mathrm{d}x_4+ 3\\mathrm{d}x_3\\wedge\\mathrm{d}x_5+ 4\\mathrm{d}x_4\\wedge\\mathrm{d}x_6+ 5\\mathrm{d}x_5\\wedge \\mathrm{d}x_7. Package idiom wedge products straightforward: (might write product -35\\mathrm{d}x_1\\wedge\\mathrm{d}x_4\\wedge\\mathrm{d}x_5\\wedge \\mathrm{d}x_6\\wedge\\mathrm{d}x_7 -21\\mathrm{d}x_1\\wedge\\mathrm{d}x_3\\wedge\\mathrm{d}x_4\\wedge\\mathrm{d}x_5\\wedge\\mathrm{d}x_6). See wedge product eliminates rows repeated entries, gathers permuted rows together (respecting sign permutation), expresses result terms elementary forms. product linear combination two elementary forms; note two coefficients possible {7\\choose 5}=21 nonzero. Note order rows product arbitrary. wedge product formal properties distributivity far interesting one associativity, demonstrate : Note carefully terms (F1 ^ F2) ^ F3 F1 ^ (F2 ^ F3) appear different order. nevertheless algebraically identical, may demonstrate calculating difference: Spivak observes \\Lambda^k(V) spanned n\\choose k wedge products form \\mathrm{d}x_{i_1}\\wedge\\mathrm{d}x_{i_2}\\wedge\\ldots\\wedge\\mathrm{d}x_{i_k}\\qquad 1\\leq i_i<i_2<\\cdots <i_k\\leq n products elementary forms (compare \\mathcal{J}^k(V), spanned n^k elementary forms). Formally, multilinearity means every element space \\Lambda^k(V) linear combination elementary forms, illustrated package function kform_general(). Consider following idiom: Object Krel two-form, specifically map \\left(\\mathbb{R}^4\\right)^2 \\mathbb{R}. Observe Krel {4\\choose 2}=6 components, appear particular order. Addition k-forms straightforward R idiom algebraically nontrivial: , note \\mathrm{d}x_2\\wedge\\mathrm{d}x_4 terms combine [give 2 4 = 113] \\mathrm{d}x_1\\wedge\\mathrm{d}x_3 term vanishes cancellation.","code":"M1 <- matrix(c(3,5,4, 4,6,1),2,3,byrow=TRUE) K1 <- as.kform(M1,c(2,7)) K1 ## An alternating linear map from V^3 to R with V=R^6: ##            val ##  1 4 6  =    7 ##  3 4 5  =   -2 M2 <- cbind(1:5,3:7) K2 <- as.kform(M2,1:5) K2 ## An alternating linear map from V^2 to R with V=R^7: ##          val ##  5 7  =    5 ##  4 6  =    4 ##  3 5  =    3 ##  2 4  =    2 ##  1 3  =    1 K1 ^ K2 ## An alternating linear map from V^5 to R with V=R^7: ##                val ##  1 3 4 5 6  =  -21 ##  1 4 5 6 7  =  -35 F1 <- as.kform(matrix(c(3,4,5, 4,6,1,3,2,1),3,3,byrow=TRUE)) F2 <- as.kform(cbind(1:6,3:8),1:6) F3 <- kform_general(1:8,2) (F1 ^ F2) ^ F3 ## An alternating linear map from V^7 to R with V=R^8: ##                    val ##  1 2 4 5 6 7 8  =   -5 ##  2 3 4 5 6 7 8  =    6 ##  1 2 3 5 6 7 8  =   11 ##  1 2 3 4 5 6 8  =    1 ##  1 2 3 4 5 7 8  =   -5 ##  1 2 3 4 6 7 8  =    2 ##  1 2 3 4 5 6 7  =    1 ##  1 3 4 5 6 7 8  =   -2 F1 ^ (F2 ^ F3) ## An alternating linear map from V^7 to R with V=R^8: ##                    val ##  2 3 4 5 6 7 8  =    6 ##  1 2 4 5 6 7 8  =   -5 ##  1 2 3 4 5 7 8  =   -5 ##  1 2 3 4 5 6 8  =    1 ##  1 2 3 4 6 7 8  =    2 ##  1 2 3 4 5 6 7  =    1 ##  1 3 4 5 6 7 8  =   -2 ##  1 2 3 5 6 7 8  =   11 (F1 ^ F2) ^ F3 - F1 ^ (F2 ^ F3) ## The zero alternating linear map from V^7 to R with V=R^n: ## empty sparse array with 7 columns Krel <- kform_general(4,2,1:6) Krel ## An alternating linear map from V^2 to R with V=R^4: ##          val ##  3 4  =    6 ##  2 4  =    5 ##  1 4  =    4 ##  2 3  =    3 ##  1 3  =    2 ##  1 2  =    1 K1 <- as.kform(matrix(1:4,2,2),c(1,109)) K2 <- as.kform(matrix(c(1,3,7,8,2,4),ncol=2,byrow=TRUE),c(-1,5,4)) K1 ## An alternating linear map from V^2 to R with V=R^4: ##          val ##  2 4  =  109 ##  1 3  =    1 K2 ## An alternating linear map from V^2 to R with V=R^8: ##          val ##  2 4  =    4 ##  7 8  =    5 ##  1 3  =   -1 K1+K2 ## An alternating linear map from V^2 to R with V=R^8: ##          val ##  2 4  =  113 ##  7 8  =    5"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"print-methods","dir":"Articles","previous_headings":"Alternating forms","what":"Print methods","title":"Exterior calculus with R","text":"Although spray form used probably direct natural representation differential forms numerical work, sometimes need algebraic print method. can represent algebraically using .symbolic() function: , U multilinear map \\left(\\mathbb{R}^5\\right)^2 \\mathbb{R}. Symbolically, represents map takes (,b,c,d,e) , b map takes (,b,c,d,e) b, . asterisk * represents tensor product \\otimes. Alternating forms work similarly k-forms different defaults: Note wedge product \\wedge, although implemented package idiom ^ %^%, appears symbolic representation ascii caret, ^. can alter default print method kform_symbolic_print option, uses .symbolic(): print option works nicely d() function elementary forms:","code":"U <- ktensor(spray(cbind(1:4,2:5),1:4)) U ## A linear map from V^2 to R with V=R^5: ##          val ##  4 5  =    4 ##  3 4  =    3 ##  2 3  =    2 ##  1 2  =    1 as.symbolic(U) ## [1]  +4 d*e +3 c*d +2 b*c + a*b K <- kform_general(3,2,1:3) K ## An alternating linear map from V^2 to R with V=R^3: ##          val ##  2 3  =    3 ##  1 3  =    2 ##  1 2  =    1 as.symbolic(K,d=\"d\",symbols=letters[23:26]) ## [1]  +3 dx^dy +2 dw^dy + dw^dx options(kform_symbolic_print = \"d\") K ## An alternating linear map from V^2 to R with V=R^3: ##  +3 dx2^dx3 +2 dx1^dx3 + dx1^dx2 (d(1) + d(5)) ^ (d(3)-5*d(2)) ^ d(7) ## An alternating linear map from V^3 to R with V=R^7: ##  - dx3^dx5^dx7 + dx1^dx3^dx7 +5 dx2^dx5^dx7 -5 dx1^dx2^dx7 options(kform_symbolic_print = NULL) # restore default"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"contractions","dir":"Articles","previous_headings":"Alternating forms","what":"Contractions","title":"Exterior calculus with R","text":"Given k-form \\phi\\colon V^k\\longrightarrow\\mathbb{R} vector \\mathbf{v}\\V, contraction \\phi_\\mathbf{v} \\phi \\mathbf{v} k-1-form \\phi_\\mathbf{v}{\\left(\\mathbf{v}^1,\\ldots,\\mathbf{v}^{k-1}\\right)} =   \\phi{\\left(\\mathbf{v},\\mathbf{v}^1,\\ldots,\\mathbf{v}^{k-1}\\right)} k>1; specify \\phi_\\mathbf{v}=\\phi(\\mathbf{v}) k=1. Verification straightforward: possible iterate contraction process; pass matrix V contract() interpreted repeated contraction columns V: pass three columns contract() result 0-form: , result coerced scalar; order work formal 0-form (represented package spray zero-column index matrix) can use lose=FALSE argument:","code":"(o <- rform())  # a random 3-form ## An alternating linear map from V^3 to R with V=R^7: ##            val ##  2 4 6  =   -6 ##  4 6 7  =    5 ##  5 6 7  =    4 ##  1 3 7  =    7 ##  1 5 7  =  -12 ##  1 4 6  =    8 ##  2 3 7  =   -2 ##  1 2 4  =    1 V <- matrix(runif(21),ncol=3) LHS <- as.function(o)(V) RHS <- as.function(contract(o,V[,1]))(V[,-1]) c(LHS=LHS,RHS=RHS,diff=LHS-RHS) ##          LHS          RHS         diff  ## 4.512547e-01 4.512547e-01 1.110223e-16 as.function(contract(o,V[,1:2]))(V[,-(1:2),drop=FALSE]) ## [1] 0.4512547 contract(o,V) ## [1] 0.4512547 contract(o,V,lose=FALSE) ## An alternating linear map from V^0 to R with V=R^0: ##            val ##   =  0.4512547"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"transformations-and-pullback","dir":"Articles","previous_headings":"Alternating forms","what":"Transformations and pullback","title":"Exterior calculus with R","text":"Suppose given two-form \\omega=\\sum_{<j}a_{ij}dx_i\\wedge dx_j relationships dx_i=\\sum_rM_{ir}dy_r, \\omega =     \\sum_{<j}     a_{ij}\\left(\\sum_rM_{ir}dy_r\\right)\\wedge\\left(\\sum_rM_{jr}dy_r\\right). general situation k-form \\omega=\\sum_{i_1<\\cdots<i_k}a_{i_1\\ldots i_k}dx_{i_1}\\wedge\\cdots\\wedge dx_{i_k} giving \\omega =     \\sum_{i_1<\\cdots <i_k}\\left[     a_{i_1<\\cdots < i_k}\\left(\\sum_rM_{i_1r}dy_r\\right)\\wedge\\cdots\\wedge\\left(\\sum_rM_{i_kr}dy_r\\right)\\right]. \\omega given terms dx_1,\\ldots,dx_k expressed terms dy_1,\\ldots,dy_k. example \\omega=   dx_1\\wedge dx_2 + 5dx_1\\wedge dx_3 \\left(   \\begin{array}{l}   dx_1\\\\   dx_2\\\\   dx_3   \\end{array}   \\right)= \\left( \\begin{array}{ccc} 1 & 4 & 7\\\\ 2 & 5 & 8\\\\ 3 & 6 & 9\\\\ \\end{array} \\right)  \\left(   \\begin{array}{l}   dy_1\\\\ dy_2\\\\   dy_3   \\end{array}   \\right) \\begin{array}{ccl}   \\omega &=& \\left(1dy_1+4dy_2+7dy_3\\right)\\wedge \\left(2dy_1+5dy_2+8dy_3\\right)+ 5\\left(1dy_1+4dy_2+7dy_3\\right)\\wedge \\left(3dy_1+6dy_2+9dy_3\\right) \\\\ &=&2dy_1\\wedge dy_1+5dy_1\\wedge dy_2+\\cdots+ 5\\cdot 7\\cdot 6dx_3\\wedge dx_2+ 5\\cdot 7\\cdot 9dx_3\\wedge dx_3+\\\\ &=& -33dy_1\\wedge dy_2-66dy_1\\wedge dy_3-33dy_2\\wedge dy_3 \\end{array} Function pullback() function : However, slow 100% sure isn’t much efficient way transformation. tests tests/testthat. show transformations may inverted using matrix inverses: transform according matrix M transform according matrix inverse; functionality works nicely magrittr pipes: see many rows values small enough print method print exact zero, sufficiently small eliminated spray internals. can remove small entries zap(): See result equal original k-form 2dy_2\\wedge dy_4\\wedge dy_5.","code":"options(kform_symbolic_print = \"dx\")   # uses dx etc in print method pullback(dx^dy+5*dx^dz, matrix(1:9,3,3)) ## An alternating linear map from V^2 to R with V=R^3: ##  -33 dx^dy -66 dx^dz -33 dy^dz options(kform_symbolic_print = NULL) # revert to default (o <- 2 * as.kform(2) ^ as.kform(4) ^ as.kform(5)) ## An alternating linear map from V^3 to R with V=R^5: ##            val ##  2 4 5  =    2 M <- matrix(rnorm(25),5,5) o |> pullback(M) |> pullback(solve(M)) ## An alternating linear map from V^3 to R with V=R^5: ##            val ##  3 4 5  =    0 ##  1 2 3  =    0 ##  2 3 5  =    0 ##  2 3 4  =    0 ##  2 4 5  =    2 ##  1 2 5  =    0 ##  1 3 4  =    0 ##  1 2 4  =    0 ##  1 3 5  =    0 ##  1 4 5  =    0 o |> pullback(M) |> pullback(solve(M)) |> zap() ## An alternating linear map from V^3 to R with V=R^5: ##            val ##  2 4 5  =    2"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"exterior-derivatives","dir":"Articles","previous_headings":"Alternating forms","what":"Exterior derivatives","title":"Exterior calculus with R","text":"Given k-form \\omega, Spivak defines differential \\omega (k+1)-form \\mathrm{d}\\omega follows. \\omega = \\sum_{ i_1 < i_2 <\\cdots<i_k} \\omega_{i_1i_2\\ldots i_k} \\mathrm{d}x^{i_1}\\wedge \\mathrm{d}x^{i_2}\\wedge\\cdots\\wedge\\mathrm{d}x^{i_k} \\mathrm{d}\\omega = \\sum_{ i_1 < i_2 <\\cdots<i_k} \\sum_{\\alpha=1}^n D_\\alpha\\left(\\omega_{i_1i_2\\ldots i_k}\\right) \\cdot \\mathrm{d}x^{i_1}\\wedge \\mathrm{d}x^{i_2}\\wedge\\cdots\\wedge\\mathrm{d}x^{i_k} D_if()=\\lim_{h\\longrightarrow 0}\\frac{f(^1,\\ldots,^+h,\\ldots,^n)-f(^1,\\ldots,^,\\ldots,^n)}{h} ordinary ^\\mathrm{th} partial derivative (Spivak, p25). Hubbard Hubbard take conceptually distinct approach define exterior derivative d\\phi (use bold font, \\mathbf{d}\\phi) k-form \\phi (k+1)-form given {d}\\phi   \\left({v}_i,\\ldots,{v}_{k+1}\\right)   =   \\lim_{h\\longrightarrow 0}\\frac{1}{h^{k+1}}\\int_{\\partial   P_{x}\\left(h{v}_1,\\ldots,h{v}_{k+1}\\right)}\\phi , account, rather opaque mathematical idiom. However, definition makes sense consistent Spivak’s definition . definition allows one express fundamental theorem calculus arbitrary number dimensions without modification. can shown \\mathrm{d}{\\left(f\\,dx_{i_1}\\wedge\\cdots\\wedge\\mathrm{d}x_{i_k}\\right)}=     \\mathrm{d}f\\wedge\\mathrm{d}x_{i_1}\\wedge\\cdots\\wedge\\mathrm{d}x_{i_k} f\\colon\\mathbb{R}^n\\longrightarrow\\mathbb{R} scalar function position. package provides grad() , given vector x_1,\\ldots,x_n returns one-form \\sum_{=1}^n x_idx_i useful \\mathrm{d}f=\\sum_{j=1}^n\\left(D_j f\\right)\\,\\mathrm{d}x_j. Thus use grad() function verify , \\mathbb{R}^n, certain (k-1)-form zero work function. Motivated fact F_3=\\frac{1}{\\left(x^2+y^2+z^2\\right)^{3/2}} \\begin{pmatrix}x\\\\y\\\\z\\end{pmatrix} divergenceless velocity field \\mathbb{R}^3, H&H go define [page 548, equation 6.7.16] \\omega_{n}=\\mathrm{d}\\frac{1}{\\left(x_1^2+\\ldots +x_n^2\\right)^{n/2}}\\sum_{=1}^{n}(-1)^{-1} x_i\\mathrm{d}x_1\\wedge\\cdots\\wedge\\widehat{\\mathrm{d}x_i}\\wedge\\cdots\\wedge\\mathrm{d}x_n (hat indicates absence term), show analytically \\mathrm{d}\\omega=0. show using R idiom. first thing define function implements hat: , example: can use grad() function calculate \\mathrm{d}\\omega, using quotient law express derivatives analytically: Thus Now can use wedge product two parts show exterior derivative zero:","code":"grad(c(0.4,0.1,-3.2,1.5)) ## An alternating linear map from V^1 to R with V=R^4: ##         val ##  4  =   1.5 ##  3  =  -3.2 ##  2  =   0.1 ##  1  =   0.4 f <- function(x){     n <- length(x)     as.kform(t(apply(diag(n)<1,2,which))) } f(1:5) ## An alternating linear map from V^4 to R with V=R^5: ##              val ##  1 2 3 4  =    1 ##  1 2 3 5  =    1 ##  1 2 4 5  =    1 ##  1 3 4 5  =    1 ##  2 3 4 5  =    1 df  <- function(x){     n <- length(x)     S <- sum(x^2)     grad(rep(c(1,-1),length=n)*(S^(n/2) - n*x^2*S^(n/2-1))/S^n     ) } df(1:5) ## An alternating linear map from V^1 to R with V=R^5: ##              val ##  5  =  -5.67e-05 ##  4  =   2.03e-05 ##  3  =   8.10e-06 ##  2  =  -2.84e-05 ##  1  =   4.05e-05 x <- rnorm(9) print(df(x) ^ f(x))  # should be zero ## An alternating linear map from V^9 to R with V=R^9: ##                        val ##  1 2 3 4 5 6 7 8 9  =    0"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"differential-of-the-differential-d20","dir":"Articles","previous_headings":"","what":"Differential of the differential, d^2=0","title":"Exterior calculus with R","text":"can use package verify celebrated fact , k-form \\phi, \\mathrm{d}\\left(\\mathrm{d}\\phi\\right)=0. first step define scalar functions f1(), f2(), f3(), 0-forms: Now need define elementary 1-forms: demonstrate theorem defining 2-form sum three elementary two-forms, evaluated particular point \\mathbb{R}^4: use slightly slicker R idiom defining elementary forms e1,e2,e3 defining phi linear sum, weighted 0-forms given (scalar) functions f1,f2,f3: Now evaluate first derivatives f1() etc point (1,2,3,4), using Deriv() Deriv package: Df1 etc numeric vectors length 4, example: calculate dphi, \\mathrm{d}\\phi, can use function grad(): Now work differential differential. First evaluate Hessians (4x4 numeric matrices) point: example (note matrix symmetric; also note carefully nonzero diagonal term). dd\\phi clearly zero Hessians symmetrical: expected.","code":"f1 <- function(w,x,y,z){x + y^3 + x*y*w*z} f2 <- function(w,x,y,z){w^2*x*y*z + sin(w) + w+z} f3 <- function(w,x,y,z){w*x*y*z + sin(x) + cos(w)} dw <- as.kform(1) dx <- as.kform(2) dy <- as.kform(3) dz <- as.kform(4) phi <-   (     +f1(1,2,3,4) ^ dw ^ dx     +f2(1,2,3,4) ^ dw ^ dy     +f3(1,2,3,4) ^ dy ^ dz   ) e1 <- dw ^ dx e2 <- dw ^ dy e3 <- dy ^ dz  phi <-   (     +f1(1,2,3,4) ^ e1     +f2(1,2,3,4) ^ e2     +f3(1,2,3,4) ^ e3   ) phi ## An alternating linear map from V^2 to R with V=R^4: ##               val ##  1 3  =  29.84147 ##  1 2  =  53.00000 ##  3 4  =  25.44960 library(\"Deriv\") Df1 <- Deriv(f1)(1,2,3,4) Df2 <- Deriv(f2)(1,2,3,4) Df3 <- Deriv(f3)(1,2,3,4) Df1 ##  w  x  y  z  ## 24 13 35  6 dphi <-   (     +grad(Df1) ^ e1     +grad(Df2) ^ e2     +grad(Df3) ^ e3   ) dphi ## An alternating linear map from V^3 to R with V=R^4: ##                 val ##  1 3 4  =  30.15853 ##  1 2 3  =  23.00000 ##  1 2 4  =   6.00000 ##  2 3 4  =  11.58385 Hf1 <- matrix(Deriv(f1,nderiv=2)(1,2,3,4),4,4) Hf2 <- matrix(Deriv(f2,nderiv=2)(1,2,3,4),4,4) Hf3 <- matrix(Deriv(f3,nderiv=2)(1,2,3,4),4,4) Hf1 ##    w  x  y z ## w  0 12  8 6 ## x 12  0  4 3 ## y  8  4 18 2 ## z  6  3  2 0 ij <- expand.grid(seq_len(nrow(Hf1)),seq_len(ncol(Hf1)))  ddphi <- # should be zero   (     +as.kform(ij,c(Hf1))     +as.kform(ij,c(Hf2))     +as.kform(ij,c(Hf3))   )  ddphi ## The zero alternating linear map from V^2 to R with V=R^n: ## empty sparse array with 2 columns"},{"path":"https://robinhankin.github.io/stokes/articles/stokes.html","id":"stokess-theorem","dir":"Articles","previous_headings":"Differential of the differential, d^2=0","what":"Stokes’s theorem","title":"Exterior calculus with R","text":"general form, Stokes’s theorem states \\int_{\\partial X}\\phi=\\int_X\\mathrm{d}\\phi X\\subset\\mathbb{R}^n compact oriented (k+1)-dimensional manifold boundary \\partial X \\phi k-form defined neighborhood X. verify Stokes, following 6.9.5 Hubbard \\phi= \\left(x_1-x_2^2+x_3^3-\\cdots\\pm x_n^n\\right) \\left( \\sum_{=1}^n \\mathrm{d}x_1\\wedge\\cdots\\wedge\\widehat{\\mathrm{d}x_i}\\wedge\\cdots\\wedge\\mathrm{d}x_n \\right) (hat indicates term absent), wish evaluate \\int_{\\partial C_a}\\phi C_a cube 0\\leq x_j\\leq , 1\\leq j\\leq n. Stokes tells us equal \\int_{C_a}\\mathrm{d}\\phi, given d\\phi = \\left( 1+2x_2+\\cdots + nx_n^{n-1}\\right) \\mathrm{d}x_1\\wedge\\cdots\\wedge\\mathrm{d}x_n volume integral just \\sum_{j=1}^n \\int_{x_1=0}^\\int_{x_2=0}^\\cdots \\int_{x_i=0}^jx_j^{j-1} dx_1 dx_2\\ldots dx_n= ^{n-1}\\left(+^2+\\cdots+^n\\right). Stokes’s theorem, trivial, amenable direct numerical verification package allow slick creation \\phi: (recall phi function maps \\mathbb{R}^9 8-forms. choose \\left(1,2,\\ldots,9\\right)\\\\mathbb{R}^9 phi(1:9) shown resulting 8-form. Thus, write \\phi_{1:9} phi(1:9) \\phi_{1:9}\\colon\\left(\\mathbb{R}^9\\right)^8\\longrightarrow\\mathbb{R}, package idiom follows: , \\mathrm{d}\\phi given (observe dphi(1:9) 9-form, \\mathrm{d}\\phi_{1:9}\\colon\\left(\\mathbb{R}^9\\right)^9\\longrightarrow\\mathbb{R}). Now consider Spivak’s theorem 4.6 (page 82), context states 9-form proportional determinant 9\\times 9 matrix formed arguments, constant proportionality equal form evaluated identity matrix I_9 [formally generally, v_1,\\ldots,v_n basis V, \\omega\\\\Lambda^n(V) w_i=\\sum a_{ij}v_j \\omega\\left(w_1,\\ldots,w_n\\right) = \\det\\left(a_{ij}\\right)\\cdot\\omega\\left(v_1,\\ldots v_n\\right)]. Numerically:","code":"phi <- function(x){     n <- length(x)     sum(x^seq_len(n)*rep_len(c(1,-1),n)) * as.kform(t(apply(diag(n)<1,2,which))) } phi(1:9) ## An alternating linear map from V^8 to R with V=R^9: ##                            val ##  2 3 4 5 6 7 8 9  =  371423053 ##  1 2 3 4 5 7 8 9  =  371423053 ##  1 3 4 5 6 7 8 9  =  371423053 ##  1 2 3 4 6 7 8 9  =  371423053 ##  1 2 3 4 5 6 7 9  =  371423053 ##  1 2 4 5 6 7 8 9  =  371423053 ##  1 2 3 5 6 7 8 9  =  371423053 ##  1 2 3 4 5 6 8 9  =  371423053 ##  1 2 3 4 5 6 7 8  =  371423053 f <- as.function(phi(1:9)) E <- matrix(runif(72),9,8)   # (R^9)^8 f(E) ## [1] -26620528 dphi <- function(x){     nn <- seq_along(x)     sum(nn*x^(nn-1)) * as.kform(seq_along(x)) } dphi(1:9) ## An alternating linear map from V^9 to R with V=R^9: ##                              val ##  1 2 3 4 5 6 7 8 9  =  405071317 f <- as.function(dphi(1:9)) E <- matrix(runif(81),9,9) f(E) ## [1] -9850953 det(E)*f(diag(9))  # should match f(E) by Spivak's 4.6 ## [1] -9850953"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/vector_cross_product.html","id":"r-implementation","dir":"Articles","previous_headings":"","what":"R implementation","title":"Functions `vector_cross_product()` and `vcp3()` in the `stokes` package","text":"stokes package (Hankin 2022b), R function vector_cross_product() takes matrix n rows n-1 columns: transpose work . stokes (R) convention interpret columns matrix vectors. wanted take cross product \\mathbf{u}=(5,-2,1) \\mathbf{v}=(1,2,0): course can work higher dimensional spaces: case n=2 vector cross product becomes unary operator single vector \\left(u,v\\right)\\\\mathbb{R}^2, returning argument rotated counterclockwise \\pi/2; case discussed end, along n=1.","code":"(M <- cbind(c(5,-2,1),c(1,2,0))) ##      [,1] [,2] ## [1,]    5    1 ## [2,]   -2    2 ## [3,]    1    0 vector_cross_product(M) ## [1] -2  1 12 vector_cross_product(matrix(rnorm(30),6,5)) ## [1]   4.715354  -1.003152 -12.051733   3.459023 -12.902338  -6.943296"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/vector_cross_product.html","id":"orientation","dir":"Articles","previous_headings":"Verification","what":"Orientation","title":"Functions `vector_cross_product()` and `vcp3()` in the `stokes` package","text":"can demonstrate function correct orientation. need ensure vectors \\mathbf{v}_1,\\ldots,\\mathbf{v}_n,\\mathbf{v}_1\\times\\cdots\\times\\mathbf{v}_n constitute right-handed basis: right-handed case. severe test right-handedness:: , see case vectors right-handed. may verify rules determinants obeyed taking dot product follows: Writing M=[v_1,\\ldots,v_6], v_i\\\\mathbb{R}^7, see dot product v_i\\cdot v_1\\times\\cdots\\times v_6 implemented crossprod() vanishes (numerical precision), determinants question two identical columns.","code":"det(cbind(M,vector_cross_product(M)))>0 ## [1] TRUE f <- function(n){   M <- matrix(rnorm(n^2+n),n+1,n)   det(cbind(M,vector_cross_product(M)))>0 }  all(sapply(sample(3:10,100,replace=TRUE),f)) ## [1] TRUE M <- matrix(rnorm(42),7,6) crossprod(M,vector_cross_product(M)) ##               [,1] ## [1,]  1.578598e-15 ## [2,]  1.110223e-16 ## [3,]  4.440892e-16 ## [4,] -3.330669e-15 ## [5,]  1.332268e-15 ## [6,] -5.440093e-15"},{"path":"https://robinhankin.github.io/stokes/articles/vector_cross_product.html","id":"immediate-properties","dir":"Articles","previous_headings":"Verification","what":"Immediate properties","title":"Functions `vector_cross_product()` and `vcp3()` in the `stokes` package","text":"Spivak gives following properties: \\mathbf{v}_{\\sigma(1)}\\times\\cdots\\times\\mathbf{v}_{\\sigma(n)} = \\operatorname{sgn}\\sigma\\cdot \\mathbf{v}_{1}\\times\\cdots\\times\\mathbf{v}_{n} \\mathbf{v}_{1} \\times\\cdots\\times \\mathbf{v}_i \\times\\cdots\\times \\mathbf{v}_{n} = \\cdot \\mathbf{v}_{1} \\times\\cdots\\times \\mathbf{v}_i \\times\\cdots\\times \\mathbf{v}_{n} \\mathbf{v}_{1} \\times\\cdots\\times \\left(\\mathbf{v}_i+{\\mathbf{v}'}_i\\right) \\times\\cdots\\times \\mathbf{v}_{n} = \\mathbf{v}_{1} \\times\\cdots\\times \\mathbf{v}_i \\times\\cdots\\times \\mathbf{v}_{n} + \\mathbf{v}_{1} \\times\\cdots\\times {\\mathbf{v}'}_i \\times\\cdots\\times \\mathbf{v}_{n} first use permutation sigma permutations package (Hankin 2020) sign -1: see two vector cross products add zero (numerical precision), sigma odd permutation. second: see second product \\pi times first (numerical precision), linearity vector cross product. third: see sum first two products equal third (numerical precision), linearity vector cross product.","code":"M <- matrix(rnorm(30),6,5) sigma <- as.cycle(\"(12)(345)\") sgn(sigma) ## [1] -1 Mdash <- M[,as.function(sigma)(seq_len(5))] vector_cross_product(M) + vector_cross_product(Mdash) ## [1]  0.000000e+00  5.551115e-17  1.332268e-15 -1.776357e-15  0.000000e+00 ## [6]  0.000000e+00 Mdash <- M Mdash[,3] <- pi*Mdash[,3] vector_cross_product(Mdash) - vector_cross_product(M) * pi ## [1]  1.065814e-14 -8.881784e-16 -3.552714e-15  7.105427e-15 -1.776357e-15 ## [6]  0.000000e+00 M1 <- M M2 <- M Msum <- M v1 <- runif(6) v2 <- runif(6) M1[,3] <- v1 M2[,3] <- v2 Msum[,3] <- v1+v2 vector_cross_product(M1) + vector_cross_product(M2) - vector_cross_product(Msum) ## [1]  0.000000e+00  2.220446e-16  0.000000e+00 -3.552714e-15  1.776357e-15 ## [6]  1.942890e-16"},{"path":"https://robinhankin.github.io/stokes/articles/vector_cross_product.html","id":"vector-products-and-the-hodge-star-operator","dir":"Articles","previous_headings":"Verification","what":"Vector products and the Hodge star operator","title":"Functions `vector_cross_product()` and `vcp3()` in the `stokes` package","text":"cross product coordinate-free definition Hodge conjugate wedge product arguments. d dimensions: \\mathbf{v}_1\\times\\cdots\\times\\mathbf{v}_{d-1}={\\star}\\left( \\mathbf{v}_1\\wedge\\cdots\\wedge\\mathbf{v}_{d-1}\\right). used function vector_cross_product() computationally inefficient (think) prone numerical roundoff errors. may verify definitions agree, using six-dimensional test case: can see vector_cross_product() returns R vector. verify correct, compare output value calculated directly wedge product: see agreement ans1 ans2 although elements might appear different order (per disordR discipline). Actually possible produce answer using slightly slicker idiom: [note different order output]. , see output vector_cross_product() [ans1] ordinary R vector, direct result [ans2] 1-form. order compare , first need coerce ans2 1-form subtract: see ans1 ans3 match within numerical precision.","code":"set.seed(2) M <- matrix(rnorm(30),6,5) (ans1 <- vector_cross_product(M)) ## [1]   4.431826  -1.966102  -3.344998  -6.853352 -11.879641   7.170485 (jj <- as.1form(M[,1]) ^ as.1form(M[,2]) ^ as.1form(M[,3]) ^ as.1form(M[,4]) ^ as.1form(M[,5])) ## An alternating linear map from V^5 to R with V=R^6: ##                      val ##  1 2 3 4 5  =   7.170485 ##  1 2 4 5 6  =   3.344998 ##  1 2 3 5 6  =  -6.853352 ##  1 3 4 5 6  =  -1.966103 ##  2 3 4 5 6  =  -4.431826 ##  1 2 3 4 6  =  11.879641 (ans2 <- hodge(jj)) ## An alternating linear map from V^1 to R with V=R^6: ##               val ##  5  =  -11.879641 ##  1  =    4.431826 ##  2  =   -1.966103 ##  4  =   -6.853352 ##  3  =   -3.344998 ##  6  =    7.170485 (ans3 <- hodge(Reduce(`^`,lapply(1:5,function(i){as.1form(M[,i])})))) ## An alternating linear map from V^1 to R with V=R^6: ##               val ##  4  =   -6.853352 ##  3  =   -3.344998 ##  1  =    4.431826 ##  5  =  -11.879641 ##  2  =   -1.966103 ##  6  =    7.170485 (diff <- as.1form(ans1) - ans3) ## An alternating linear map from V^1 to R with V=R^6: ##        val ##  1  =    0 ##  2  =    0 ##  3  =    0 ##  4  =    0 ##  5  =    0 ##  6  =    0 coeffs(diff) ## A disord object with hash 8e9298ff6d77253137fe25d06acabd9c369e4321 and elements ## [1]  3.552714e-15  1.776357e-15 -1.332268e-15  1.776357e-15  7.105427e-15 ## [6] -4.440892e-15 ## (in some order)"},{"path":"https://robinhankin.github.io/stokes/articles/vector_cross_product.html","id":"vector-cross-products-in-3-dimensions","dir":"Articles","previous_headings":"Verification","what":"Vector cross products in 3 dimensions","title":"Functions `vector_cross_product()` and `vcp3()` in the `stokes` package","text":"Taking Spivak’s definition face value, define vector cross product \\mathbf{u}\\times\\mathbf{v} three-vectors \\mathbf{u} \\mathbf{v} map tangent space reals, \\left(\\mathbf{u}\\times\\mathbf{v}\\right)(\\mathbf{w})= \\left(\\mathbf{u}\\times\\mathbf{v}\\right)\\cdot\\mathbf{w} =\\left(I_\\mathbf{u}\\right)_\\mathbf{v}(\\mathbf{w}), 3-volume element subscripts refer contraction. Package idiom : However, note 3D vector cross products implemented package function vcp3(), uses different idiom: preferable grounds coercion 1-form explicit. Suppose wish take vector cross product \\mathbf{u}=\\left(1,4,2\\right)^T \\mathbf{v}=\\left(2,1,5\\right)^T: , note order lines implementation-specific per disordR discipline (Hankin 2022a), form agree basis vector evaluation given . Object p vector cross product \\mathbf{u} \\mathbf{v}, given one-form. can see mnemonic operation coercing p function evaluating three basis vectors \\mathbb{R}^3: see agreement mnemonic \\det\\begin{pmatrix}&j&k\\\\1&4&2\\\\2&1&5\\end{pmatrix}. , may evaluate triple cross product (\\mathbf{u}\\times\\mathbf{v})\\cdot\\mathbf{w} evaluating ucv() \\mathbf{w}. shows agreement elementary mnemonic \\det\\begin{pmatrix}1&-3&2\\\\1&4&2\\\\2&1&5\\end{pmatrix}=7, expected linearity.","code":"function(u,v){contract(volume(3),cbind(u,v))} vcp3 ## function(u,v){hodge(as.1form(u)^as.1form(v))} u <- c(1,4,2) v <- c(2,1,5) (p <- vcp3(u,v))  # 'p' for (cross) product ## An alternating linear map from V^1 to R with V=R^3: ##        val ##  1  =   18 ##  2  =   -1 ##  3  =   -7 ucv  <- as.function(p) c(i=ucv(ex), j=ucv(ey), k=ucv(ez)) ##  i  j  k  ## 18 -1 -7 w <- c(1,-3,2) ucv(w) ## [1] 7"},{"path":"https://robinhankin.github.io/stokes/articles/vector_cross_product.html","id":"vector-cross-product-identities","dir":"Articles","previous_headings":"Verification","what":"Vector cross product identities","title":"Functions `vector_cross_product()` and `vcp3()` in the `stokes` package","text":"following identities standard results: \\begin{aligned} \\mathbf{u}\\times(\\mathbf{v}\\times\\mathbf{w}) &= \\mathbf{v}(\\mathbf{w}\\cdot\\mathbf{u})-\\mathbf{w}(\\mathbf{u}\\cdot\\mathbf{v})\\\\ (\\mathbf{u}\\times\\mathbf{v})\\times\\mathbf{w} &= \\mathbf{v}(\\mathbf{w}\\cdot\\mathbf{u})-\\mathbf{u}(\\mathbf{v}\\cdot\\mathbf{w})\\\\ (\\mathbf{u}\\times\\mathbf{v})\\times(\\mathbf{u}\\times\\mathbf{w}) &= (\\mathbf{u}\\cdot(\\mathbf{v}\\times\\mathbf{w}))\\mathbf{u}  \\\\ (\\mathbf{u}\\times\\mathbf{v})\\cdot(\\mathbf{w}\\times\\mathbf{x})  &= (\\mathbf{u}\\cdot\\mathbf{w})(\\mathbf{v}\\cdot\\mathbf{x}) -                                                                   (\\mathbf{u}\\cdot\\mathbf{x})(\\mathbf{v}\\cdot\\mathbf{w}) \\end{aligned} may verify four together:","code":"x <- c(-6,5,7)  # u,v,w as before c(   hodge(as.1form(u) ^ vcp3(v,w))        == as.1form(v*sum(w*u) - w*sum(u*v)),   hodge(vcp3(u,v) ^ as.1form(w))        == as.1form(v*sum(w*u) - u*sum(v*w)),   as.1form(as.function(vcp3(v,w))(u)*u) == hodge(vcp3(u,v) ^ vcp3(u,w))     ,   hodge(hodge(vcp3(u,v)) ^ vcp3(w,x))   == sum(u*w)*sum(v*x) - sum(u*x)*sum(v*w) ) ## [1] TRUE TRUE TRUE TRUE"},{"path":"https://robinhankin.github.io/stokes/articles/vector_cross_product.html","id":"edge-cases","dir":"Articles","previous_headings":"Verification","what":"Edge-cases","title":"Functions `vector_cross_product()` and `vcp3()` in the `stokes` package","text":"Function vector_cross_product() takes matrix n rows n-1 columns. consider cases n=2 n=1. Firstly, n=2. Going back Spivak’s definition, see cross product unary operation takes single vector \\mathbf{v}\\\\mathbb{R}^2; might write {\\times}(\\mathbf{v})={\\times}(v_1,v_2). Formally define \\phi(w)= \\mathrm{det} \\begin{pmatrix} v_1&v_2\\\\ w_1&w_2 \\end{pmatrix} seek vector \\mathbf{z}=(z_1,z_2)\\\\mathbb{R}^2 \\left\\langle\\mathbf{w},\\mathbf{z}\\right\\rangle=\\phi(\\mathbf{w}). Thus \\phi(\\mathbf{w})=v_1w_2-v_2w_1 see \\mathbf{z}=(-v_2,v_1). Numerically: see vector cross product single vector \\mathbf{v}\\\\mathbb{R}^2 vector \\mathbf{v} rotated \\pi/2 counterclockwise; dot product \\mathbf{v} {\\times}{\\left(\\mathbf{v}\\right)} zero. Now try even peculiar case n=1, corresponding matrix one row zero columns. Formally, cross product nullary operation takes zero vectors \\mathbf{v}\\\\mathbb{R}^1 returns “vector” \\mathbf{z}\\\\mathbb{R}^1. vector cross product case n=1 thus scalar. following Spivak see \\phi map \\mathbb{R}^1 reals, \\phi(w_1)=\\det(w_1)=w_1; seek z_1\\\\mathbb{R} \\phi(w_1)=\\left\\langle w_1,z_1\\right\\rangle; w_1z_1=w_1 z_1=1. Matrices zero columns one row easily created R: Function vector_cross_product() takes argument: thus returning scalar 1 intended. Examining body vector_cross_product head document see function boils returning determinant determinant zero--zero matrix equal 1 [zero zero matrix maps \\left\\lbrace 0\\right\\rbrace thus identity map, definition determinant 1]. Numerically:","code":"vector_cross_product(rbind(4,7)) ## [1] -7  4 M <- matrix(data=NA,nrow=1,ncol=0) M ##      ## [1,] dput(M) ## structure(logical(0), dim = 1:0) vector_cross_product(M) ## [1] 1 M[-1,,drop=FALSE] ## <0 x 0 matrix> det(matrix(NA,0,0)) ## [1] 1"},{"path":[]},{"path":[]},{"path":"https://robinhankin.github.io/stokes/articles/wedge.html","id":"digression-function-spraycross","dir":"Articles","previous_headings":"","what":"Digression: function spraycross()","title":"Functions `wedge()` and `wedge2()` in the `stokes` package","text":"Function wedge() essentially convenience wrapper spraycross(); meat wedge2() last line: kform(spraycross(K1, K2)). Function spraycross() part spray package gives tensor product sparse arrays, interpreted multivariate polynomials: Observe spraycross() (association wedge()) associative distributive commutative.","code":"(a <- spray(matrix(1:4,2,2),c(2,5))) ##          val ##  2 4  =    5 ##  1 3  =    2 (b <- spray(matrix(c(10,11,12,13),2,2),c(7,11))) ##            val ##  11 13  =   11 ##  10 12  =    7 spraycross(a,b) ##                val ##  1 3 10 12  =   14 ##  1 3 11 13  =   22 ##  2 4 10 12  =   35 ##  2 4 11 13  =   55 spraycross(b,a) ##                val ##  10 12 1 3  =   14 ##  11 13 1 3  =   22 ##  10 12 2 4  =   35 ##  11 13 2 4  =   55"},{"path":"https://robinhankin.github.io/stokes/articles/wedge.html","id":"cut-to-the-chase-wedge2","dir":"Articles","previous_headings":"Digression: function spraycross()","what":"Cut to the chase: wedge2()","title":"Functions `wedge()` and `wedge2()` in the `stokes` package","text":"Function wedge2() takes two kforms start simple example: looks like combinatorial term included . express x y tensors (objects class ktensor) show combinatorial term arises. functions, y ty identical: equivalent can see y compact efficient representation ty: alternating tensors y alternatingness built evaluation, ty alternating virtue including permutations arguments, sign permutation. can evaluate Spivak’s formula (without combinatorial term) x\\wedge y coercing ktensors using tensorprod(): , coefficient equal \\pm 35 (sign coming sign permutation), 2!3!=12 rows. can now calculate \\operatorname{Alt}(z), 5!=120 rows, one per permutation [5], coefficient \\pm\\frac{12\\times 35}{5!}=\\pm 3.5. define x\\wedge y \\frac{5!}{3!2!}\\operatorname{Alt}(z), coefficient \\pm\\frac{5!}{3!2!}\\cdot\\frac{12\\times 35}{5!}=35. know x\\wedge y alternating form. represent object class kform, need kform object single index entry 1 2 3 4 7. need coefficient 35, grounds linear, alternating, maps \\begin{pmatrix} 1&0&0&0&0\\\\ 0&1&0&0&0\\\\ 0&0&1&0&0\\\\ 0&0&0&1&0\\\\ 0&0&0&0&0\\\\ 0&0&0&0&0\\\\ 0&0&0&0&1 \\end{pmatrix} 35; indeed see: conclude, combinatorial term present R idiom, just difficult see first glance.","code":"(x <- as.kform(cbind(1,2),5)) ## An alternating linear map from V^2 to R with V=R^2: ##          val ##  1 2  =    5 (y <- as.kform(cbind(3,4,7),7)) ## An alternating linear map from V^3 to R with V=R^7: ##            val ##  3 4 7  =    7 wedge2(x,y) ## An alternating linear map from V^5 to R with V=R^7: ##                val ##  1 2 3 4 7  =   35 tx <- as.ktensor(x)    # \"tx\" = tensor 'x' (ty <- as.ktensor(y))   # \"ty\" = tensor 'y' ## A linear map from V^3 to R with V=R^7: ##            val ##  7 4 3  =   -7 ##  7 3 4  =    7 ##  4 7 3  =    7 ##  4 3 7  =   -7 ##  3 7 4  =   -7 ##  3 4 7  =    7 M <- matrix(round(rnorm(21),2),7,3) # member of (R^7)^3 c(as.function(y)(M),as.function(ty)(M)) ## [1] 15.23211 15.23211 7*(  +M[3,1]*M[4,2]*M[7,3]   -M[3,1]*M[4,3]*M[7,2]   -M[3,2]*M[4,1]*M[7,3]   +M[3,2]*M[4,3]*M[7,1]   +M[3,3]*M[4,1]*M[7,2]  -M[3,3]*M[4,2]*M[7,1]  ) ## [1] 15.23211 (z <- tensorprod(as.ktensor(x),as.ktensor(y))) ## A linear map from V^5 to R with V=R^7: ##                val ##  1 2 3 4 7  =   35 ##  2 1 3 7 4  =   35 ##  1 2 4 3 7  =  -35 ##  2 1 3 4 7  =  -35 ##  1 2 4 7 3  =   35 ##  2 1 4 3 7  =   35 ##  2 1 4 7 3  =  -35 ##  1 2 7 3 4  =   35 ##  2 1 7 3 4  =  -35 ##  1 2 3 7 4  =  -35 ##  1 2 7 4 3  =  -35 ##  2 1 7 4 3  =   35 wedge(x,y) ## An alternating linear map from V^5 to R with V=R^7: ##                val ##  1 2 3 4 7  =   35"},{"path":"https://robinhankin.github.io/stokes/articles/wedge.html","id":"algebraic-properties","dir":"Articles","previous_headings":"","what":"Algebraic properties","title":"Functions `wedge()` and `wedge2()` in the `stokes` package","text":"First note \\Lambda^k(V) vector space (considered kform vignette). \\omega,\\omega_i\\\\Lambda^k(V) \\eta,\\eta_i\\\\Lambda^l(V) \\begin{eqnarray} (\\omega_1+\\omega_2)\\wedge\\eta &=& \\omega_1\\wedge\\eta+\\omega_2\\wedge\\eta\\\\ \\omega\\wedge(\\eta_1+\\eta_2) &=&\\omega\\wedge\\eta_1 + \\omega\\wedge\\eta_2\\\\ \\end{eqnarray} (, wedge product left- right- distributive); \\\\mathbb{R} \\begin{equation} \\omega\\wedge\\eta = \\omega\\wedge \\eta=(\\omega\\wedge\\eta) \\end{equation} \\begin{equation} \\omega\\wedge\\eta = (-1)^{kl}\\eta\\wedge\\omega. \\end{equation} rules make expansion wedge products possible expressing general kform terms basis \\Lambda^k(V). Spivak (1965) tells us , v_1,\\ldots,v_k basis V, set \\begin{equation} \\phi_{i_1}\\wedge\\phi_{i_2}\\wedge\\cdots\\wedge\\phi_{i_k}\\qquad 1\\leq i_1 < \\cdots < i_k\\leq n \\end{equation} basis \\Lambda^k(V) \\phi_i(v_j)=\\delta_{ij}. package expresses k-form terms basis following example: algebraic notation, omega (\\omega) 5\\phi_1\\wedge\\phi_2\\wedge\\phi_8+6\\phi_1\\wedge\\phi_3\\wedge\\phi_7 may write \\omega=5\\phi_{128}+6\\phi_{137}. take wedge product \\eta=2\\phi_{235}+3\\phi_{356} write \\begin{eqnarray} \\omega\\wedge\\eta &=& (5\\phi_{128}+6\\phi_{137})\\wedge (2\\phi_{235}+3\\phi_{356})\\\\ &=& 10\\phi_{128}\\wedge\\phi_{235} + 15\\phi_{128}\\wedge\\phi_{356} +     12\\phi_{137}\\wedge\\phi_{235} + 18\\phi_{137}\\wedge\\phi_{356}\\\\ &=& 10\\phi_1\\wedge\\phi_2\\wedge\\phi_8\\wedge\\phi_2\\wedge\\phi_3\\wedge\\phi_5 + 15\\phi_1\\wedge\\phi_2\\wedge\\phi_8\\wedge\\phi_3\\wedge\\phi_5\\wedge\\phi_6\\\\&{}&\\qquad + 12\\phi_1\\wedge\\phi_3\\wedge\\phi_7\\wedge\\phi_2\\wedge\\phi_3\\wedge\\phi_5 + 18\\phi_1\\wedge\\phi_3\\wedge\\phi_7\\wedge\\phi_3\\wedge\\phi_5\\wedge\\phi_6\\\\ &=& 0+ 15\\phi_1\\wedge\\phi_2\\wedge\\phi_8\\wedge\\phi_3\\wedge\\phi_5\\wedge\\phi_6+0+0\\\\ &=& -15\\phi_1\\wedge\\phi_2\\wedge\\phi_3\\wedge\\phi_5\\wedge\\phi_6\\wedge\\phi_8 \\end{eqnarray} used rules repeatedly (especially fact \\omega\\wedge\\omega=0 alternating form). Package idiom : See function wedge() legwork.","code":"(omega <- as.kform(rbind(c(1,2,8),c(1,3,7)),5:6)) ## An alternating linear map from V^3 to R with V=R^8: ##            val ##  1 3 7  =    6 ##  1 2 8  =    5 eta <- as.kform(rbind(c(2,3,5),c(3,5,6)),2:3) wedge(omega,eta) ## An alternating linear map from V^6 to R with V=R^8: ##                  val ##  1 2 3 5 6 8  =  -15"},{"path":[]},{"path":"https://robinhankin.github.io/stokes/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robin K. S. Hankin. Author, maintainer.","code":""},{"path":"https://robinhankin.github.io/stokes/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Robin K. S. Hankin (2022). “Stokes's theorem R.” doi:10.48550/ARXIV.2210.17008, https://arxiv.org/abs/2210.17008.","code":"@Misc{,   title = {Stokes's theorem in R},   author = {{Robin K. S. Hankin}},   year = {2022},   publisher = {arXiv},   doi = {10.48550/ARXIV.2210.17008},   url = {https://arxiv.org/abs/2210.17008}, }"},{"path":[]},{"path":[]},{"path":"https://robinhankin.github.io/stokes/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"The Exterior Calculus","text":"stokes package provides functionality working exterior calculus. includes tensor products wedge products variety use-cases. canonical reference Spivak (see references). detailed vignette provided package. package deals -tensors -forms. -tensor multilinear map ,  considered vector space. Given two -tensors  package can calculate outer product  using natural R idiom (see vignette details). -form alternating -tensor, -tensor  property linear dependence  implies . Given -forms , package provides R idiom calculating wedge product .","code":""},{"path":"https://robinhankin.github.io/stokes/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"The Exterior Calculus","text":"can install released version stokes CRAN :","code":"# install.packages(\"stokes\")  # uncomment this to install the package library(\"stokes\") set.seed(0)"},{"path":"https://robinhankin.github.io/stokes/index.html","id":"the-stokes-package-in-use","dir":"","previous_headings":"","what":"The stokes package in use","title":"The Exterior Calculus","text":"package two main classes objects, kform ktensor. package, can create -tensor supplying function .ktensor() matrix indices vector coefficients, example: , object jj equal  (see Spivak, p76 details). can coerce tensors function evaluate : Tensor products implemented: see .","code":"jj <- as.ktensor(rbind(1:3,2:4),1:2) jj #> A linear map from V^3 to R with V=R^4: #>            val #>  2 3 4  =    2 #>  1 2 3  =    1 KT <- as.ktensor(cbind(1:4,2:5),1:4) f <- as.function(KT) E <- matrix(rnorm(10),5,2) f(E) #> [1] 11.23556 KT %X% KT #> A linear map from V^4 to R with V=R^5: #>              val #>  1 2 1 2  =    1 #>  2 3 1 2  =    2 #>  3 4 3 4  =    9 #>  2 3 4 5  =    8 #>  1 2 2 3  =    2 #>  1 2 4 5  =    4 #>  4 5 4 5  =   16 #>  2 3 3 4  =    6 #>  4 5 3 4  =   12 #>  1 2 3 4  =    3 #>  3 4 4 5  =   12 #>  3 4 2 3  =    6 #>  4 5 2 3  =    8 #>  3 4 1 2  =    3 #>  2 3 2 3  =    4 #>  4 5 1 2  =    4"},{"path":"https://robinhankin.github.io/stokes/index.html","id":"alternating-forms","dir":"","previous_headings":"","what":"Alternating forms","title":"The Exterior Calculus","text":"alternating form (-form) antisymmetric -tensor; package can convert general -tensor alternating form using Alt() function: However, package provides bespoke efficient representation -forms objects class kform. objects may created using .kform() function: , see KF equal . may coerce KF functional form: , evaluate KF point  [three columns matrix E interpreted vectors ].","code":"Alt(KT) #> A linear map from V^2 to R with V=R^5: #>           val #>  5 4  =  -2.0 #>  4 5  =   2.0 #>  4 3  =  -1.5 #>  3 2  =  -1.0 #>  2 3  =   1.0 #>  3 4  =   1.5 #>  2 1  =  -0.5 #>  1 2  =   0.5 M <- matrix(c(4,2,3,1,2,4),2,3,byrow=TRUE) M #>      [,1] [,2] [,3] #> [1,]    4    2    3 #> [2,]    1    2    4 KF <- as.kform(M,c(1,5)) KF #> An alternating linear map from V^3 to R with V=R^4: #>            val #>  1 2 4  =    5 #>  2 3 4  =    1 f <- as.function(KF) E <- matrix(rnorm(12),4,3) f(E) #> [1] -5.979544"},{"path":"https://robinhankin.github.io/stokes/index.html","id":"the-wedge-product","dir":"","previous_headings":"","what":"The wedge product","title":"The Exterior Calculus","text":"wedge product two -forms implemented ^ wedge(): package can accommodate number results exterior calculus elementary forms: number useful functions exterior calculus provided, gradient scalar function: package takes leg-work exterior calculus:","code":"KF2 <- kform_general(6:9,2,1:6) KF2 #> An alternating linear map from V^2 to R with V=R^9: #>          val #>  8 9  =    6 #>  7 9  =    5 #>  6 9  =    4 #>  7 8  =    3 #>  6 8  =    2 #>  6 7  =    1 KF ^ KF2 #> An alternating linear map from V^5 to R with V=R^9: #>                val #>  1 2 4 6 7  =    5 #>  1 2 4 6 8  =   10 #>  2 3 4 6 8  =    2 #>  2 3 4 7 8  =    3 #>  2 3 4 6 9  =    4 #>  1 2 4 6 9  =   20 #>  2 3 4 6 7  =    1 #>  2 3 4 7 9  =    5 #>  1 2 4 7 8  =   15 #>  2 3 4 8 9  =    6 #>  1 2 4 7 9  =   25 #>  1 2 4 8 9  =   30 dx <- as.kform(1) dy <- as.kform(2) dz <- as.kform(3) dx ^ dy ^ dz  # element of volume  #> An alternating linear map from V^3 to R with V=R^3: #>            val #>  1 2 3  =    1 grad(1:6) #> An alternating linear map from V^1 to R with V=R^6: #>        val #>  6  =    6 #>  5  =    5 #>  4  =    4 #>  3  =    3 #>  2  =    2 #>  1  =    1 grad(1:4) ^ grad(1:6) #> An alternating linear map from V^2 to R with V=R^6: #>          val #>  4 5  =   20 #>  1 5  =    5 #>  2 5  =   10 #>  3 5  =   15 #>  2 6  =   12 #>  4 6  =   24 #>  3 6  =   18 #>  1 6  =    6"},{"path":"https://robinhankin.github.io/stokes/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"The Exterior Calculus","text":"concise reference Spivak 1971. Calculus manifolds, Addison-Wesley. leisurely book Hubbard Hubbard 2015. Vector calculus, linear algebra, differential forms: unified approach. Matrix Editions","code":""},{"path":"https://robinhankin.github.io/stokes/index.html","id":"further-information","dir":"","previous_headings":"","what":"Further information","title":"The Exterior Calculus","text":"detail, see package vignette vignette(\"stokes\")","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Alt.html","id":null,"dir":"Reference","previous_headings":"","what":"Alternating multilinear forms — Alt","title":"Alternating multilinear forms — Alt","text":"Converts \\(k\\)-tensor alternating form","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Alt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alternating multilinear forms — Alt","text":"","code":"Alt(S,give_kform)"},{"path":"https://robinhankin.github.io/stokes/reference/Alt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alternating multilinear forms — Alt","text":"S multilinear form, object class ktensor give_kform Boolean, default FALSE meaning return     alternating \\(k\\)-tensor [, object class     ktensor happens alternating] TRUE     meaning return \\(k\\)-form [, object class     kform]","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Alt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Alternating multilinear forms — Alt","text":"Given \\(k\\)-tensor \\(T\\), $$\\mathrm{Alt}(T)\\left(v_1,\\ldots,v_k\\right)=     \\frac{1}{k!}\\sum_{\\sigma\\S_k}\\mathrm{sgn}(\\sigma)\\cdot     T\\left(v_{\\sigma(1)},\\ldots,v_{\\sigma(k)}\\right)   $$ Thus example \\(k=3\\): $$\\mathrm{Alt}(T)\\left(v_1,v_2,v_3\\right)=       \\frac{1}{6}\\left(\\begin{array}{c}       +T\\left(v_1,v_2,v_3\\right)\\quad       -T\\left(v_1,v_3,v_2\\right)\\cr       -T\\left(v_2,v_1,v_3\\right)\\quad       +T\\left(v_2,v_3,v_1\\right)\\cr       +T\\left(v_3,v_1,v_2\\right)\\quad       -T\\left(v_3,v_2,v_1\\right)       \\end{array}       \\right)     $$ reasonably easy see \\(\\mathrm{Alt}(T)\\)     alternating, sense $$\\mathrm{Alt}(T)\\left(v_1,\\ldots,v_i,\\ldots,v_j,\\ldots,v_k\\right)=     -\\mathrm{Alt}(T)\\left(v_1,\\ldots,v_j,\\ldots,v_i,\\ldots,v_k\\right)   $$ Function Alt() intended take return object   class ktensor; given kform object, just   returns argument unchanged. short vignette provided package: type   vignette(\"Alt\") commandline.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Alt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alternating multilinear forms — Alt","text":"Returns alternating \\(k\\)-tensor.  work \\(k\\)-forms,   much efficient representation alternating tensors,   use .kform().","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Alt.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Alternating multilinear forms — Alt","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/Alt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Alternating multilinear forms — Alt","text":"","code":"(X <- ktensor(spray(rbind(1:3),6))) #> A linear map from V^3 to R with V=R^3: #>            val #>  1 2 3  =    6 Alt(X) #> A linear map from V^3 to R with V=R^3: #>            val #>  3 2 1  =   -1 #>  3 1 2  =    1 #>  2 3 1  =    1 #>  2 1 3  =   -1 #>  1 3 2  =   -1 #>  1 2 3  =    1 Alt(X,give_kform=TRUE) #> An alternating linear map from V^3 to R with V=R^3: #>            val #>  1 2 3  =    1  S <- as.ktensor(expand.grid(1:3,1:3),rnorm(9)) S #> A linear map from V^2 to R with V=R^3: #>                 val #>  3 3  =  -0.2441996 #>  2 3  =  -0.2473253 #>  1 3  =  -1.8218177 #>  3 2  =   1.1484116 #>  2 2  =   0.6215527 #>  1 2  =  -0.0055713 #>  3 1  =  -2.4372636 #>  2 1  =   0.2553171 #>  1 1  =  -1.4000435 Alt(S) #> A linear map from V^2 to R with V=R^3: #>                 val #>  3 2  =   0.6978685 #>  3 1  =  -0.3077230 #>  2 3  =  -0.6978685 #>  1 3  =   0.3077230 #>  2 1  =   0.1304442 #>  1 2  =  -0.1304442  issmall(Alt(S) - Alt(Alt(S)))  # should be TRUE; Alt() is idempotent #> [1] TRUE  a <- rtensor() V <- matrix(rnorm(21),ncol=3) LHS <- as.function(Alt(a))(V) RHS <- as.function(Alt(a,give_kform=TRUE))(V) c(LHS=LHS,RHS=RHS,diff=LHS-RHS) #>           LHS           RHS          diff  #> -2.071708e-01 -2.071708e-01  1.665335e-16"},{"path":"https://robinhankin.github.io/stokes/reference/Ops.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic Ops Group Methods for kform and ktensor objects — Ops.kform","title":"Arithmetic Ops Group Methods for kform and ktensor objects — Ops.kform","text":"Allows arithmetic operators used \\(k\\)-forms   \\(k\\)-tensors addition, multiplication, etc,   defined.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Ops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic Ops Group Methods for kform and ktensor objects — Ops.kform","text":"","code":"# S3 method for class 'kform' Ops(e1, e2 = NULL) # S3 method for class 'ktensor' Ops(e1, e2 = NULL)"},{"path":"https://robinhankin.github.io/stokes/reference/Ops.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic Ops Group Methods for kform and ktensor objects — Ops.kform","text":"e1,e2 Objects class kform ktensor","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Ops.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arithmetic Ops Group Methods for kform and ktensor objects — Ops.kform","text":"functions Ops.kform() Ops.ktensor() pass unary   binary arithmetic operators (“+”, “-”,   “*”, “/” “^”)   appropriate specialist function coercing spray objects. wedge products \\(k\\)-forms, use wedge()   %^% ^; tensor products   \\(k\\)-tensors, use tensorprod() %X%.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Ops.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic Ops Group Methods for kform and ktensor objects — Ops.kform","text":"functions documented return object class   kform ktensor.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Ops.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Arithmetic Ops Group Methods for kform and ktensor objects — Ops.kform","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Ops.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Arithmetic Ops Group Methods for kform and ktensor objects — Ops.kform","text":"plain asterisk, “*” behaves differently ktensors   kforms.  Given two ktensors T1, T2,   “T1*T2” return tensor product.    grounds idiom one natural interpretation.    use discouraged (use %X% tensorprod()   instead).  asterisk can also used multiply tensor   scalar, T1*5. asterisk used multiply two kforms K1,   K2, K1*K2, always return error.   grounds sensible interpretation general   probably meant use wedge product, K1^K2.  Note   multiplication scalars acceptable, K1*6.   note K1*K2 returns error even one   0-form (scalar), K1*scalar(3).  behaviour may   change future. package caret (“^”) evaluates wedge   product; note %^% also acceptable.  Powers simply   make sense alternating forms: S %^% S = S^S zero   identically.  caret interpreted consistently wedge   product, one factors numeric interpreted   zero-form (, scalar).  Thus S^2 = wedge(S,2) = 2^S =   S*2 = S+S, indeed S^n==S*n.  Caveat emptor!  S   kform object, tempting [incorrect]   interpret “S^3” something like “S   power 3”.  See also note Ops.clifford   clifford package. Powers implemented ktensors grounds ktensor   power zero defined. Note one take care order operations mix   ^ *.  example, dx ^ (6*dy) perfectly   acceptable; (dx ^ 6)*dy) return error,   unbracketed form dx ^ 6 * dy.  second case attempt   use asterisk multiply two k-forms, triggers error.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/Ops.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic Ops Group Methods for kform and ktensor objects — Ops.kform","text":"","code":"## dx_1 ^ dx_2 + 6dx_5 ^ dx_6: as.kform(1) ^ as.kform(2) + 6*as.kform(5) ^ as.kform(6) #> An alternating linear map from V^2 to R with V=R^6: #>          val #>  1 2  =    1 #>  5 6  =    6  k1 <- kform_general(4,2,rnorm(6)) k2 <- kform_general(4,2,rnorm(6))  E <- matrix(rnorm(8),4,2) as.function(k1+k2)(E) #> [1] -1.278449  ## verify linearity, here 2*k1 + 3*k2: as.function(2*k1+3*k2)(E)-(2*as.function(k1)(E) + 3*as.function(k2)(E)) #> [1] -1.221245e-15 ## should be small"},{"path":"https://robinhankin.github.io/stokes/reference/as.1form.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce vectors to 1-forms — as.1form","title":"Coerce vectors to 1-forms — as.1form","text":"Given vector, return corresponding 1-form; exterior   derivative 0-form (, scalar function).  Function   grad() synonym.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/as.1form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce vectors to 1-forms — as.1form","text":"","code":"as.1form(v) grad(v)"},{"path":"https://robinhankin.github.io/stokes/reference/as.1form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce vectors to 1-forms — as.1form","text":"v vector element \\(\\) \\(\\partial f/\\partial       x_i\\)","code":""},{"path":"https://robinhankin.github.io/stokes/reference/as.1form.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce vectors to 1-forms — as.1form","text":"exterior derivative \\(k\\)-form \\(\\phi\\) \\((k+1)\\)-form \\(\\mathrm{d}\\phi\\) given $$   \\mathrm{d}\\phi   \\left(   P_\\mathbf{x}\\left(\\mathbf{v}_i,\\ldots,\\mathbf{v}_{k+1}\\right)   \\right)   =   \\lim_{h\\longrightarrow 0}\\frac{1}{h^{k+1}}\\int_{\\partial   P_\\mathbf{x}\\left(h\\mathbf{v}_1,\\ldots,h\\mathbf{v}_{k+1}\\right)}\\phi   $$ can use facts $$     \\mathrm{d}\\left(f\\,\\mathrm{d}x_{i_1}\\wedge\\cdots\\wedge\\mathrm{d}x_{i_k}\\right)=     \\mathrm{d}f\\wedge\\mathrm{d}x_{i_1}\\wedge\\cdots\\wedge\\mathrm{d}x_{i_k}   $$   $$     \\mathrm{d}f=\\sum_{j=1}^n\\left(D_j f\\right)\\,\\mathrm{d}x_j   $$ calculate differentials  general \\(k\\)-forms. Specifically, $$     \\phi=\\sum_{1\\leq i_i < \\cdots < i_k\\leq n} a_{i_1\\ldots       i_k}\\mathrm{d}x_{i_1}\\wedge\\cdots\\wedge\\mathrm{d}x_{i_k}   $$   $$     \\mathrm{d}\\phi=     \\sum_{1\\leq i_i < \\cdots < i_k\\leq n}     [\\sum_{j=1}^nD_ja_{i_1\\ldots       i_k}\\mathrm{d}x_j]\\wedge\\mathrm{d}x_{i_1}\\wedge     \\cdots\\wedge\\mathrm{d}x_{i_k.}   $$ entry square brackets given grad().  See examples appropriate R idiom.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/as.1form.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce vectors to 1-forms — as.1form","text":"one-form","code":""},{"path":"https://robinhankin.github.io/stokes/reference/as.1form.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coerce vectors to 1-forms — as.1form","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/as.1form.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce vectors to 1-forms — as.1form","text":"","code":"as.1form(1:9)  # note ordering of terms #> An alternating linear map from V^1 to R with V=R^9: #>        val #>  9  =    9 #>  8  =    8 #>  7  =    7 #>  6  =    6 #>  5  =    5 #>  4  =    4 #>  3  =    3 #>  2  =    2 #>  1  =    1   as.1form(rnorm(20)) #> An alternating linear map from V^1 to R with V=R^20: #>                val #>   1  =  -0.8607243 #>  14  =  -0.4321952 #>   2  =   0.4212304 #>  15  =  -0.6675648 #>   3  =   1.4505432 #>  16  =   1.3895059 #>   4  =   0.1943924 #>  13  =  -0.7820777 #>  12  =  -0.7721921 #>  11  =   0.9110785 #>  10  =  -0.7160587 #>   9  =  -1.7810619 #>   8  =  -0.9441017 #>   7  =   2.7361084 #>  20  =  -0.7893881 #>  19  =   2.5844322 #>   6  =   1.3398599 #>  18  =   0.2053894 #>   5  =  -0.6912054 #>  17  =   0.9118739  grad(c(4,7)) ^ grad(1:4) #> An alternating linear map from V^2 to R with V=R^4: #>          val #>  1 2  =    1 #>  1 3  =   12 #>  2 3  =   21 #>  1 4  =   16 #>  2 4  =   28"},{"path":"https://robinhankin.github.io/stokes/reference/coeffs.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract and manipulate coefficients — coeffs","title":"Extract and manipulate coefficients — coeffs","text":"Extract manipulate coefficients ktensor kform objects;   using methods spray package. Functions .spray() nterms() imported   spray.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/coeffs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract and manipulate coefficients — coeffs","text":"see coefficients kform ktensor object,   use coeffs(), returns disord object (  actually spray::coeffs()).  Replacement methods also use   methods spray package.  Note disordR   discipline enforced. Experimental functionality “pure” extraction   replacement provided, following spray version 1.0-25   .  Thus idiom [abs(coeffs()) > 0.1] indeed   [coeffs() < 1] <- 0 work expected.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/coeffs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract and manipulate coefficients — coeffs","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/coeffs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract and manipulate coefficients — coeffs","text":"","code":"(a <- kform_general(5,2,1:10)) #> An alternating linear map from V^2 to R with V=R^5: #>          val #>  2 5  =    8 #>  1 5  =    7 #>  3 4  =    6 #>  2 4  =    5 #>  4 5  =   10 #>  1 4  =    4 #>  2 3  =    3 #>  1 3  =    2 #>  3 5  =    9 #>  1 2  =    1 coeffs(a) # a disord object #> A disord object with hash 3f2a0e8670c7c27e53fa60649745f5057067487d and elements #>  [1]  8  7  6  5 10  4  3  2  9  1 #> (in some order) coeffs(a)[coeffs(a)%%2==1] <- 100  # replace every odd coeff with 100 a #> An alternating linear map from V^2 to R with V=R^5: #>          val #>  1 2  =  100 #>  3 5  =  100 #>  1 3  =    2 #>  2 3  =  100 #>  1 4  =    4 #>  4 5  =   10 #>  2 4  =  100 #>  3 4  =    6 #>  1 5  =  100 #>  2 5  =    8  coeffs(a*0) #> numeric(0)  a <- rform() a[coeffs(a) < 5]         # experimental #>            val #>  3 4 6  =    1 #>  2 3 7  =   -2 #>  1 4 6  =    3 #>  2 5 6  =   -5 #>  1 3 5  =   -8 #>  2 4 7  =   -4 a[coeffs(a) > 3] <- 99   # experimental"},{"path":"https://robinhankin.github.io/stokes/reference/consolidate.html","id":null,"dir":"Reference","previous_headings":"","what":"Various low-level helper functions — consolidate","title":"Various low-level helper functions — consolidate","text":"Various low-level helper functions used Alt()   kform()","code":""},{"path":"https://robinhankin.github.io/stokes/reference/consolidate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Various low-level helper functions — consolidate","text":"","code":"consolidate(S) kill_trivial_rows(S) include_perms(S) kform_to_ktensor(S)"},{"path":"https://robinhankin.github.io/stokes/reference/consolidate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Various low-level helper functions — consolidate","text":"S Object class spray","code":""},{"path":"https://robinhankin.github.io/stokes/reference/consolidate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Various low-level helper functions — consolidate","text":"Low-level helper functions.  Function consolidate() takes spray object,     combines rows identical permutation, respecting     sign permutation Function kill_trivial_rows() takes spray object     deletes rows repeated entry (\\(k\\)-forms     identically zero) Function include_perms() replaces row     spray object permutations, respecting sign     permutation Function ktensor_to_kform() coerces \\(k\\)-form     \\(k\\)-tensor","code":""},{"path":"https://robinhankin.github.io/stokes/reference/consolidate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Various low-level helper functions — consolidate","text":"functions documented return spray object.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/consolidate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Various low-level helper functions — consolidate","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/consolidate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Various low-level helper functions — consolidate","text":"","code":"(S <- spray(matrix(c(1,1,2,2,1,3,3,1,3,5),ncol=2,byrow=TRUE),1:5)) #>          val #>  3 5  =    5 #>  3 1  =    4 #>  1 3  =    3 #>  2 2  =    2 #>  1 1  =    1  kill_trivial_rows(S)  # (rows 1 and 3 killed, repeated entries) #>          val #>  1 3  =    3 #>  3 1  =    4 #>  3 5  =    5 consolidate(S)        # (merges rows 2 and 4) #>          val #>  1 1  =    1 #>  2 2  =    2 #>  1 3  =   -1 #>  3 5  =    5 include_perms(S)      # returns a spray object, not alternating tensor. #>          val #>  5 3  =   -5 #>  3 5  =    5 #>  3 1  =    1 #>  1 3  =   -1"},{"path":"https://robinhankin.github.io/stokes/reference/contract.html","id":null,"dir":"Reference","previous_headings":"","what":"Contractions of \\(k\\)-forms — contract","title":"Contractions of \\(k\\)-forms — contract","text":"contraction natural linear map \\(k\\)-forms \\(k-1\\)-forms.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/contract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contractions of \\(k\\)-forms — contract","text":"","code":"contract(K,v,lose=TRUE) contract_elementary(o,v)"},{"path":"https://robinhankin.github.io/stokes/reference/contract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contractions of \\(k\\)-forms — contract","text":"K \\(k\\)-form o Integer-valued vector corresponding one row index     matrix lose Boolean, default TRUE meaning coerce     \\(0\\)-form scalar FALSE meaning return     formal \\(0\\)-form v vector; function contract(), matrix,     interpret column vector contract ","code":""},{"path":"https://robinhankin.github.io/stokes/reference/contract.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Contractions of \\(k\\)-forms — contract","text":"Given \\(k\\)-form \\(\\phi\\) vector \\(\\mathbf{v}\\), contraction \\(\\phi_\\mathbf{v}\\) \\(\\phi\\) \\(\\mathbf{v}\\) \\(k-1\\)-form $$   \\phi_\\mathbf{v}\\left(\\mathbf{v}^1,\\ldots,\\mathbf{v}^{k-1}\\right) =   \\phi\\left(\\mathbf{v},\\mathbf{v}^1,\\ldots,\\mathbf{v}^{k-1}\\right)   $$ provided \\(k>1\\); \\(k=1\\) specify \\(\\phi_\\mathbf{v}=\\phi(\\mathbf{v})\\). Function contract_elementary() low-level helper function translates elementary \\(k\\)-forms coefficient 1 (form integer vector corresponding one row index matrix) contraction \\(\\mathbf{v}\\). extensive vignette package, vignette(\"contract\").","code":""},{"path":"https://robinhankin.github.io/stokes/reference/contract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contractions of \\(k\\)-forms — contract","text":"Returns object class kform.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/contract.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Contractions of \\(k\\)-forms — contract","text":"Steven H. Weintraub 2014. “Differential forms: theory practice”, Elsevier (Definition 2.2.23, chapter 2, page 77).","code":""},{"path":"https://robinhankin.github.io/stokes/reference/contract.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Contractions of \\(k\\)-forms — contract","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/contract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contractions of \\(k\\)-forms — contract","text":"","code":"contract(as.kform(1:5),1:8) #> An alternating linear map from V^4 to R with V=R^5: #>              val #>  1 2 3 4  =    5 #>  1 2 4 5  =    3 #>  2 3 4 5  =    1 #>  1 3 4 5  =   -2 #>  1 2 3 5  =   -4 contract(as.kform(1),3)   # 0-form #> [1] 3    contract_elementary(c(1,2,5),c(1,2,10,11,71)) #> An alternating linear map from V^2 to R with V=R^5: #>          val #>  1 5  =   -2 #>  2 5  =    1 #>  1 2  =   71   ## Now some verification [takes ~10s to run]: #o <- kform(spray(t(replicate(2, sample(9,4))), runif(2))) #V <- matrix(rnorm(36),ncol=4) #jj <- c( #   as.function(o)(V), #   as.function(contract(o,V[,1,drop=TRUE]))(V[,-1]), # scalar #   as.function(contract(o,V[,1:2]))(V[,-(1:2),drop=FALSE]), #   as.function(contract(o,V[,1:3]))(V[,-(1:3),drop=FALSE]), #   as.function(contract(o,V[,1:4],lose=FALSE))(V[,-(1:4),drop=FALSE]) #)  #print(jj) #max(jj) - min(jj) # zero to numerical precision"},{"path":"https://robinhankin.github.io/stokes/reference/dovs.html","id":null,"dir":"Reference","previous_headings":"","what":"Dimension of the underlying vector space — dovs","title":"Dimension of the underlying vector space — dovs","text":"\\(k\\)-form \\(\\omega\\\\Lambda^k(V)\\) maps \\(V^k\\) reals, \\(V=\\mathbb{R}^n\\). Function dovs() returns \\(n\\), dimensionality underlying vector space.  function almost trivial, returning maximum index matrix. Special dispensation given zero-forms zero tensors, return zero. Vignette dovs provides discussion.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/dovs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dimension of the underlying vector space — dovs","text":"","code":"dovs(K)"},{"path":"https://robinhankin.github.io/stokes/reference/dovs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dimension of the underlying vector space — dovs","text":"K \\(k\\)-form \\(k\\)-tensor","code":""},{"path":"https://robinhankin.github.io/stokes/reference/dovs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dimension of the underlying vector space — dovs","text":"Returns non-negative integer","code":""},{"path":"https://robinhankin.github.io/stokes/reference/dovs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Dimension of the underlying vector space — dovs","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/dovs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dimension of the underlying vector space — dovs","text":"","code":"dovs(rform()) #> [1] 7  table(replicate(20,dovs(rform(3))))   #>  #>  5  7  #>  1 19"},{"path":"https://robinhankin.github.io/stokes/reference/dx.html","id":null,"dir":"Reference","previous_headings":"","what":"Elementary forms in three-dimensional space — dx","title":"Elementary forms in three-dimensional space — dx","text":"Objects dx, dy dz three elementary one-forms three-dimensional space.  objects can generated running script vignettes/dx.Rmd, includes discussion technical documentation creates file dx.rda resides data/ directory. default print method little opaque objects.  print intuitively, use documented print.Rd.","code":"options(kform_symbolic_print = \"dx\")"},{"path":"https://robinhankin.github.io/stokes/reference/dx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elementary forms in three-dimensional space — dx","text":"","code":"data(dx)"},{"path":"https://robinhankin.github.io/stokes/reference/dx.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Elementary forms in three-dimensional space — dx","text":"See vignettes dx exeyez extended   discussion; use-case given vector_cross_product.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/dx.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Elementary forms in three-dimensional space — dx","text":"M. Spivak 1971. Calculus manifolds,   Addison-Wesley","code":""},{"path":"https://robinhankin.github.io/stokes/reference/dx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Elementary forms in three-dimensional space — dx","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/dx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Elementary forms in three-dimensional space — dx","text":"","code":"dx #> An alternating linear map from V^1 to R with V=R^1: #>        val #>  1  =    1 hodge(dx) #> [1] 1 hodge(dx,3) #> An alternating linear map from V^2 to R with V=R^3: #>          val #>  2 3  =    1   dx  # default print method, not particularly intelligible #> An alternating linear map from V^1 to R with V=R^1: #>        val #>  1  =    1 options(kform_symbolic_print = 'dx')  # shows dx dy dz dx #> An alternating linear map from V^1 to R with V=R^1: #>  + dx  dx^dz #> An alternating linear map from V^2 to R with V=R^3: #>  + dx^dz  hodge(dx,3) #> An alternating linear map from V^2 to R with V=R^3: #>  + dy^dz   as.function(dx)(ex) #> [1] 1   options(kform_symbolic_print = NULL)  # revert to default"},{"path":"https://robinhankin.github.io/stokes/reference/ex.html","id":null,"dir":"Reference","previous_headings":"","what":"Basis vectors in three-dimensional space — ex","title":"Basis vectors in three-dimensional space — ex","text":"Objects ex, ey ez three elementary one-forms three-dimensional space, sometimes denoted \\((e_x,e_y,e_z)\\).  objects can generated running script vignettes/ex.Rmd, includes discussion technical documentation creates file exeyez.rda resides data/ directory.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/ex.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Basis vectors in three-dimensional space — ex","text":"See vignettes dx ex extended   discussion; use-case given vector_cross_product.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/ex.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Basis vectors in three-dimensional space — ex","text":"M. Spivak 1971. Calculus manifolds,   Addison-Wesley","code":""},{"path":"https://robinhankin.github.io/stokes/reference/ex.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Basis vectors in three-dimensional space — ex","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/ex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basis vectors in three-dimensional space — ex","text":"","code":"as.function(dx)(ex) #> [1] 1  (X <- as.kform(matrix(1:12,nrow=4),c(1,2,7,11))) #> An alternating linear map from V^3 to R with V=R^12: #>             val #>  4 8 12  =   11 #>  3 7 11  =    7 #>  2 6 10  =    2 #>  1 5  9  =    1 as.function(X)(cbind(e(2,12),e(6,12),e(10,12))) #> [1] 2"},{"path":"https://robinhankin.github.io/stokes/reference/hodge.html","id":null,"dir":"Reference","previous_headings":"","what":"Hodge star operator — hodge","title":"Hodge star operator — hodge","text":"Given \\(k\\)-form, return Hodge dual","code":""},{"path":"https://robinhankin.github.io/stokes/reference/hodge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hodge star operator — hodge","text":"","code":"hodge(K, n=dovs(K), g, lose=TRUE)"},{"path":"https://robinhankin.github.io/stokes/reference/hodge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hodge star operator — hodge","text":"K Object class kform n Dimensionality space, defaulting largest element     index g Diagonal metric tensor, missing default     standard metric identity matrix.  Currently, entries     \\(\\pm 1\\) accepted lose Boolean, default TRUE meaning coerce     scalar appropriate","code":""},{"path":"https://robinhankin.github.io/stokes/reference/hodge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hodge star operator — hodge","text":"Given \\(k\\)-form, \\(n\\)-dimensional space,   return \\((n-k)\\)-form.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/hodge.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hodge star operator — hodge","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/hodge.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Hodge star operator — hodge","text":"authors write Hodge dual \\(\\psi\\)   \\(*\\psi\\) \\(\\star\\psi\\), Weintraub   uses \\(\\psi *\\).","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/hodge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hodge star operator — hodge","text":"","code":"(o <- kform_general(5,2,1:10)) #> An alternating linear map from V^2 to R with V=R^5: #>          val #>  2 5  =    8 #>  1 5  =    7 #>  3 4  =    6 #>  2 4  =    5 #>  4 5  =   10 #>  1 4  =    4 #>  2 3  =    3 #>  1 3  =    2 #>  3 5  =    9 #>  1 2  =    1 hodge(o) #> An alternating linear map from V^3 to R with V=R^5: #>            val #>  3 4 5  =    1 #>  1 2 4  =   -9 #>  2 4 5  =   -2 #>  2 3 5  =    4 #>  1 2 3  =   10 #>  1 4 5  =    3 #>  1 3 5  =   -5 #>  1 2 5  =    6 #>  2 3 4  =   -7 #>  1 3 4  =    8 o == hodge(hodge(o)) #> [1] TRUE  Faraday <- kform_general(4,2,runif(6)) # Faraday electromagnetic tensor mink <- c(-1,1,1,1)  # Minkowski metric hodge(Faraday,g=mink) #> An alternating linear map from V^2 to R with V=R^4: #>                 val #>  3 4  =  -0.6140056 #>  2 4  =   0.4414992 #>  1 4  =   0.3155947 #>  2 3  =  -0.1013138 #>  1 3  =  -0.2726462 #>  1 2  =   0.6536994  Faraday  == Faraday |>       hodge(g=mink) |>       hodge(g=mink) |>       hodge(g=mink) |>       hodge(g=mink) #> [1] TRUE  hodge(dx,3) == dy^dz #> [1] TRUE   ## Some edge-cases: hodge(scalar(1),2) #> An alternating linear map from V^2 to R with V=R^2: #>          val #>  1 2  =    1 hodge(zeroform(5),9) #> The zero alternating linear map from V^4 to R with V=R^n: #> empty sparse array with 4 columns hodge(volume(5)) #> [1] 1 hodge(volume(5),lose=TRUE) #> [1] 1 hodge(scalar(7),n=9) #> An alternating linear map from V^9 to R with V=R^9: #>                        val #>  1 2 3 4 5 6 7 8 9  =    7"},{"path":"https://robinhankin.github.io/stokes/reference/inner.html","id":null,"dir":"Reference","previous_headings":"","what":"Inner product operator — inner","title":"Inner product operator — inner","text":"inner product","code":""},{"path":"https://robinhankin.github.io/stokes/reference/inner.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inner product operator — inner","text":"","code":"inner(M)"},{"path":"https://robinhankin.github.io/stokes/reference/inner.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inner product operator — inner","text":"M square matrix","code":""},{"path":"https://robinhankin.github.io/stokes/reference/inner.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inner product operator — inner","text":"Returns \\(k\\)-tensor, inner product","code":""},{"path":"https://robinhankin.github.io/stokes/reference/inner.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inner product operator — inner","text":"inner product two vectors \\(\\mathbf{x}\\) \\(\\mathbf{y}\\) usually written \\(\\left\\langle\\mathbf{x},\\mathbf{y}\\right\\rangle\\) \\(\\mathbf{x}\\cdot\\mathbf{y}\\), general form \\(\\mathbf{x}^TM\\mathbf{y}\\) \\(M\\) matrix. Noting inner products multilinear, \\(\\left\\langle\\mathbf{x},\\mathbf{y}+b\\mathbf{z}\\right\\rangle=\\left\\langle\\mathbf{x},\\mathbf{y}\\right\\rangle+b\\left\\langle\\mathbf{x},\\mathbf{z}\\right\\rangle\\) \\(\\left\\langle \\mathbf{x}+b\\mathbf{y},\\mathbf{z}\\right\\rangle=\\left\\langle\\mathbf{x},\\mathbf{z}\\right\\rangle+b\\left\\langle\\mathbf{y},\\mathbf{z}\\right\\rangle\\), see inner product indeed multilinear map, , tensor. Given square matrix \\(M\\), function inner(M) returns \\(2\\)-form maps \\(\\mathbf{x},\\mathbf{y}\\) \\(\\mathbf{x}^TM\\mathbf{y}\\).  Non-square matrices effectively padded zeros. short vignette provided package: type vignette(\"inner\") commandline.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/inner.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Inner product operator — inner","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/inner.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inner product operator — inner","text":"","code":"inner(diag(7)) #> A linear map from V^2 to R with V=R^7: #>          val #>  6 6  =    1 #>  7 7  =    1 #>  5 5  =    1 #>  3 3  =    1 #>  2 2  =    1 #>  4 4  =    1 #>  1 1  =    1 inner(matrix(1:9,3,3)) #> A linear map from V^2 to R with V=R^3: #>          val #>  3 3  =    9 #>  2 3  =    8 #>  1 3  =    7 #>  3 2  =    6 #>  2 2  =    5 #>  1 2  =    4 #>  3 1  =    3 #>  2 1  =    2 #>  1 1  =    1  ## Compare the following two: Alt(inner(matrix(1:9,3,3)))      # An alternating k tensor #> A linear map from V^2 to R with V=R^3: #>          val #>  3 2  =   -1 #>  3 1  =   -2 #>  2 3  =    1 #>  1 3  =    2 #>  2 1  =   -1 #>  1 2  =    1 as.kform(inner(matrix(1:9,3,3))) # Same thing coerced to a kform #> An alternating linear map from V^2 to R with V=R^3: #>          val #>  2 3  =    2 #>  1 3  =    4 #>  1 2  =    2  f <- as.function(inner(diag(7))) X <- matrix(rnorm(14),ncol=2)  # random element of (R^7)^2 f(X) - sum(X[,1]*X[,2]) # zero to numerical precision #> [1] 0  ## verify positive-definiteness: g <- as.function(inner(crossprod(matrix(rnorm(56),8,7)))) stopifnot(g(kronecker(rnorm(7),t(c(1,1))))>0)"},{"path":"https://robinhankin.github.io/stokes/reference/issmall.html","id":null,"dir":"Reference","previous_headings":"","what":"Is a form zero to within numerical precision? — issmall","title":"Is a form zero to within numerical precision? — issmall","text":"Given \\(k\\)-form, return TRUE “small”","code":""},{"path":"https://robinhankin.github.io/stokes/reference/issmall.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is a form zero to within numerical precision? — issmall","text":"","code":"issmall(M, tol=1e-8)"},{"path":"https://robinhankin.github.io/stokes/reference/issmall.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is a form zero to within numerical precision? — issmall","text":"M Object class kform ktensor tol Small tolerance, defaulting 1e-8","code":""},{"path":"https://robinhankin.github.io/stokes/reference/issmall.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is a form zero to within numerical precision? — issmall","text":"Returns logical","code":""},{"path":"https://robinhankin.github.io/stokes/reference/issmall.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Is a form zero to within numerical precision? — issmall","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/issmall.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is a form zero to within numerical precision? — issmall","text":"","code":"o <- kform_general(3,2,runif(3)) M <- matrix(rnorm(9),3,3)  discrepancy <- o - pullback(pullback(o,M),solve(M))  discrepancy # print method might imply coefficients are zeros #> An alternating linear map from V^2 to R with V=R^3: #>          val #>  1 2  =    0 #>  1 3  =    0 #>  2 3  =    0  issmall(discrepancy)  # should be TRUE #> [1] TRUE is.zero(discrepancy)  # might be FALSE #> [1] FALSE"},{"path":"https://robinhankin.github.io/stokes/reference/keep.html","id":null,"dir":"Reference","previous_headings":"","what":"Keep or drop variables — keep","title":"Keep or drop variables — keep","text":"Keep drop variables","code":""},{"path":"https://robinhankin.github.io/stokes/reference/keep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Keep or drop variables — keep","text":"","code":"keep(K, yes) discard(K, no)"},{"path":"https://robinhankin.github.io/stokes/reference/keep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Keep or drop variables — keep","text":"K Object class kform yes,Specification dimensions either keep (yes) discard     ()","code":""},{"path":"https://robinhankin.github.io/stokes/reference/keep.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Keep or drop variables — keep","text":"Function keep(omega,yes) keeps terms specified   discard(omega,) discards terms specified.  clear   functions mean mathematical perspective.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/keep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Keep or drop variables — keep","text":"functions documented return kform object.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/keep.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Keep or drop variables — keep","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/keep.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Keep or drop variables — keep","text":"","code":"(o <- kform_general(7,3,seq_len(choose(7,3)))) #> An alternating linear map from V^3 to R with V=R^7: #>            val #>  2 5 6  =   18 #>  4 5 6  =   20 #>  3 4 6  =   16 #>  2 4 6  =   15 #>  1 5 7  =   27 #>  1 2 4  =    2 #>  1 3 6  =   12 #>  2 4 5  =    9 #>  1 4 5  =    8 #>  2 3 5  =    7 #>  1 3 5  =    6 #>  1 4 6  =   14 #>  2 3 6  =   13 #>  2 3 7  =   23 #>  1 4 7  =   24 #>  1 3 7  =   22 #>  2 4 7  =   25 #>  3 4 7  =   26 #>  4 5 7  =   30 #>  3 5 7  =   29 #>  1 6 7  =   31 #>  2 3 4  =    4 #>  1 2 7  =   21 #>  2 5 7  =   28 #>  3 6 7  =   33 #>  3 4 5  =   10 #>  1 2 6  =   11 #>  4 6 7  =   34 #>  1 2 3  =    1 #>  5 6 7  =   35 #>  3 5 6  =   19 #>  2 6 7  =   32 #>  1 2 5  =    5 #>  1 5 6  =   17 #>  1 3 4  =    3 keep(o,1:4)   # keeps only terms with dimensions 1-4 #> An alternating linear map from V^3 to R with V=R^4: #>            val #>  1 3 4  =    3 #>  1 2 3  =    1 #>  2 3 4  =    4 #>  1 2 4  =    2 discard(o,1:2)  # loses any term with a \"1\" in the index #> An alternating linear map from V^3 to R with V=R^7: #>            val #>  3 5 6  =   19 #>  5 6 7  =   35 #>  4 6 7  =   34 #>  3 4 5  =   10 #>  3 6 7  =   33 #>  3 5 7  =   29 #>  4 5 7  =   30 #>  3 4 7  =   26 #>  3 4 6  =   16 #>  4 5 6  =   20"},{"path":"https://robinhankin.github.io/stokes/reference/kform.html","id":null,"dir":"Reference","previous_headings":"","what":"k-forms — kform","title":"k-forms — kform","text":"Functionality dealing \\(k\\)-forms","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"k-forms — kform","text":"","code":"kform(S) as.kform(M,coeffs,lose=TRUE) kform_basis(n, k) kform_general(W,k,coeffs,lose=TRUE) is.kform(x) d(i) e(i,n) # S3 method for class 'kform' as.function(x,...)"},{"path":"https://robinhankin.github.io/stokes/reference/kform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"k-forms — kform","text":"n Dimension vector space \\(V=\\mathbb{R}^n\\) Integer k \\(k\\)-form maps \\(V^k\\) \\(\\mathbb{R}\\) W Integer vector dimensions M,coeffs Index matrix coefficients \\(k\\)-form S Object class spray lose Boolean, default TRUE meaning coerce     \\(0\\)-form scalar FALSE meaning return     formal \\(0\\)-form x Object class kform ... arguments, currently ignored","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"k-forms — kform","text":"\\(k\\)-form alternating \\(k\\)-tensor.    package, \\(k\\)-forms represented sparse arrays   (spray objects), class c(\"kform\",   \"spray\").  constructor function kform() takes   spray object returns kform object: ensures   rows index matrix strictly nonnegative integers,   repeated entries, strictly increasing.  Function   .kform() user-friendly.  kform() constructor function.  takes     spray object returns kform. .kform() also returns kform bit     user-friendly  kform(). kform_basis() low-level helper function     returns matrix whose rows constitute basis vector space     \\(\\Lambda^k(\\mathbb{R}^n)\\) \\(k\\)-forms. kform_general() returns kform object terms     span space alternating tensors. .kform() returns TRUE argument     kform object. d() easily-typed synonym     .kform().  idea d(1) = dx,     d(2)=dy, d(5)=dx^5, etc.  Also note ,     example, d(1:3)=dx^dy^dz, volume form. Recall \\(k\\)-tensor multilinear map \\(V^k\\)   reals, \\(V=\\mathbb{R}^n\\) vector space.   multilinear \\(k\\)-tensor \\(T\\) alternating   satisfies $$T\\left(v_1,\\ldots,v_i,\\ldots,v_j,\\ldots,v_k\\right)=     -T\\left(v_1,\\ldots,v_j,\\ldots,v_i,\\ldots,v_k\\right)   $$ package, object class kform efficient   representation alternating tensor. Function kform_basis() low-level helper function   returns matrix whose rows constitute basis vector space   \\(\\Lambda^k(\\mathbb{R}^n)\\) \\(k\\)-forms: $$\\phi=\\sum_{1\\leq i_1 < \\cdots < i_k\\leq n} a_{i_1\\ldots       i_k}\\mathrm{d}x_{i_1}\\wedge\\cdots\\wedge\\mathrm{d}x_{i_k}$$ indeed : $$a_{i_1\\ldots i_k}=\\phi\\left(\\mathbf{e}_{i_1},\\ldots,\\mathbf{e}_{i_k}\\right)   $$ \\(\\mathbf{e}_j,1\\leq j\\leq k\\) basis   \\(V\\).","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"k-forms — kform","text":"functions documented return kform object except   .function.kform(), returns function,   .kform(), returns Boolean, e(),   returns conjugate basis d().","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kform.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"k-forms — kform","text":"Hubbard Hubbard; Spivak","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kform.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"k-forms — kform","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kform.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"k-forms — kform","text":"Hubbard Hubbard use term “\\(k\\)-form”, Spivak   .","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/kform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"k-forms — kform","text":"","code":"as.kform(cbind(1:5,2:6),rnorm(5)) #> An alternating linear map from V^2 to R with V=R^6: #>                 val #>  5 6  =   0.5444861 #>  4 5  =  -1.0890789 #>  3 4  =   1.2160401 #>  2 3  =   0.3283649 #>  1 2  =   0.0958810 kform_general(1:4,2,coeffs=1:6)  # used in electromagnetism #> An alternating linear map from V^2 to R with V=R^4: #>          val #>  3 4  =    6 #>  2 4  =    5 #>  1 4  =    4 #>  2 3  =    3 #>  1 3  =    2 #>  1 2  =    1  K1 <- as.kform(cbind(1:5,2:6),rnorm(5)) K2 <- kform_general(5:8,2,1:6) K1^K2  # or wedge(K1,K2) #> An alternating linear map from V^4 to R with V=R^8: #>                     val #>  3 4 5 6  =  -0.6919527 #>  1 2 6 8  =   2.3063637 #>  3 4 6 7  =  -2.0758580 #>  4 5 7 8  =   0.0413158 #>  2 3 7 8  =  -8.9265907 #>  1 2 7 8  =   2.7676364 #>  3 4 6 8  =  -3.4597634 #>  1 2 6 7  =   1.3838182 #>  3 4 5 8  =  -2.7678107 #>  2 3 5 6  =  -1.4877651 #>  3 4 5 7  =  -1.3839054 #>  2 3 5 7  =  -2.9755302 #>  2 3 6 7  =  -4.4632953 #>  1 2 5 6  =   0.4612727 #>  1 2 5 8  =   1.8450909 #>  4 5 6 7  =   0.0206579 #>  5 6 7 8  =  -0.9240797 #>  1 2 5 7  =   0.9225455 #>  3 4 7 8  =  -4.1517161 #>  4 5 6 8  =   0.0344298 #>  2 3 6 8  =  -7.4388255 #>  2 3 5 8  =  -5.9510604  d(1:3) #> An alternating linear map from V^3 to R with V=R^3: #>            val #>  1 2 3  =    1 dx^dy^dz   # same thing #> An alternating linear map from V^3 to R with V=R^3: #>            val #>  1 2 3  =    1  d(sample(9)) # coeff is +/-1 depending on even/odd permutation of 1:9 #> An alternating linear map from V^9 to R with V=R^9: #>                        val #>  1 2 3 4 5 6 7 8 9  =   -1  f <- as.function(wedge(K1,K2)) E <- matrix(rnorm(32),8,4) f(E) + f(E[,c(1,3,2,4)])  # should be zero by alternating property #> [1] 0  options(kform_symbolic_print = 'd') (d(5)+d(7)) ^ (d(2)^d(5) + 6*d(4)^d(7)) #> An alternating linear map from V^3 to R with V=R^7: #>  -6 dx4^dx5^dx7 + dx2^dx5^dx7  options(kform_symbolic_print = NULL)  # revert to default"},{"path":"https://robinhankin.github.io/stokes/reference/kinner.html","id":null,"dir":"Reference","previous_headings":"","what":"Inner product of two kforms — kinner","title":"Inner product of two kforms — kinner","text":"Given two \\(k\\)-forms \\(\\alpha\\) \\(\\beta\\),   return inner product   \\(\\left\\langle\\alpha,\\beta\\right\\rangle\\).    underlying vector space \\(V\\) \\(\\mathcal{R}^n\\). inner product symmetric bilinear form defined two stages.   First, specify behaviour decomposable \\(k\\)-forms   \\(\\alpha=\\alpha_1\\wedge\\cdots\\wedge\\alpha_k\\)   \\(\\beta=\\beta_1\\wedge\\cdots\\wedge\\beta_k\\) $$     \\left\\langle\\alpha,\\beta\\right\\rangle=\\det\\left(     \\left\\langle\\alpha_i,\\beta_j\\right\\rangle_{1\\leq ,j\\leq n}\\right)   $$ secondly, extend whole \\(\\Lambda^k(V)\\) linearity.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kinner.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inner product of two kforms — kinner","text":"","code":"kinner(o1,o2,M)"},{"path":"https://robinhankin.github.io/stokes/reference/kinner.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inner product of two kforms — kinner","text":"o1,o2 Objects class kform M Matrix","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kinner.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inner product of two kforms — kinner","text":"Returns real number","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kinner.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Inner product of two kforms — kinner","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/kinner.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Inner product of two kforms — kinner","text":"vignette available: type vignette(\"kinner\")   command line.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/kinner.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inner product of two kforms — kinner","text":"","code":"a <- (2*dx)^(3*dy) b <- (5*dx)^(7*dy)  kinner(a,b) #> [1] 210 det(matrix(c(2*5,0,0,3*7),2,2))  # mathematically identical, slight numerical mismatch #> [1] 210"},{"path":"https://robinhankin.github.io/stokes/reference/ktensor.html","id":null,"dir":"Reference","previous_headings":"","what":"k-tensors — ktensor","title":"k-tensors — ktensor","text":"Functionality \\(k\\)-tensors","code":""},{"path":"https://robinhankin.github.io/stokes/reference/ktensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"k-tensors — ktensor","text":"","code":"ktensor(S) as.ktensor(M,coeffs) is.ktensor(x) # S3 method for class 'ktensor' as.function(x,...)"},{"path":"https://robinhankin.github.io/stokes/reference/ktensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"k-tensors — ktensor","text":"M,coeffs Matrix indices coefficients,     spray(M,coeffs) S Object class spray x Object class ktensor ... arguments, currently ignored","code":""},{"path":"https://robinhankin.github.io/stokes/reference/ktensor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"k-tensors — ktensor","text":"\\(k\\)-tensor object \\(S\\) map \\(V^k\\) reals \\(R\\), \\(V\\) vector space (\\(R^n\\)) satisfies multilinearity: $$S\\left(v_1,\\ldots,av_i,\\ldots,v_k\\right)=\\cdot   S\\left(v_1,\\ldots,v_i,\\ldots,v_k\\right)$$ $$S\\left(v_1,\\ldots,v_i+{v_i}',\\ldots,v_k\\right)=S\\left(v_1,\\ldots,v_i,\\ldots,x_v\\right)+   S\\left(v_1,\\ldots,{v_i}',\\ldots,v_k\\right).$$ Note equivalent linearity \\(V^{nk}\\) (see examples). stokes package, \\(k\\)-tensors represented sparse arrays (spray objects), class c(\"ktensor\", \"spray\").  natural efficient representation tensors takes advantage sparsity using spray package features. Function .ktensor() coerce \\(k\\)-form \\(k\\)-tensor via kform_to_ktensor().","code":""},{"path":"https://robinhankin.github.io/stokes/reference/ktensor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"k-tensors — ktensor","text":"functions documented return ktensor object   except .function.ktensor(), returns function.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/ktensor.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"k-tensors — ktensor","text":"Spivak 1961","code":""},{"path":"https://robinhankin.github.io/stokes/reference/ktensor.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"k-tensors — ktensor","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/ktensor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"k-tensors — ktensor","text":"","code":"as.ktensor(cbind(1:4,2:5,3:6),1:4) #> A linear map from V^3 to R with V=R^6: #>            val #>  4 5 6  =    4 #>  3 4 5  =    3 #>  2 3 4  =    2 #>  1 2 3  =    1   ## Test multilinearity: k <- 4 n <- 5 u <- 3  ## Define a randomish k-tensor: S  <- ktensor(spray(matrix(1+sample(u*k)%%n,u,k),seq_len(u)))  ## And a random point in V^k: E <- matrix(rnorm(n*k),n,k)    E1 <- E2 <- E3 <- E  x1 <- rnorm(n) x2 <- rnorm(n) r1 <- rnorm(1) r2 <- rnorm(1)  # change one column: E1[,2] <- x1 E2[,2] <- x2 E3[,2] <- r1*x1 + r2*x2  f <- as.function(S)  r1*f(E1) + r2*f(E2) -f(E3) # should be small #> [1] 2.220446e-16  ## Note that multilinearity is different from linearity: r1*f(E1) + r2*f(E2) - f(r1*E1 + r2*E2)  # not small! #> [1] -0.4413777"},{"path":"https://robinhankin.github.io/stokes/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print methods for \\(k\\)-tensors and \\(k\\)-forms — print.stokes","title":"Print methods for \\(k\\)-tensors and \\(k\\)-forms — print.stokes","text":"Print methods  objects options printing matrix form multivariate polynomial form","code":""},{"path":"https://robinhankin.github.io/stokes/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print methods for \\(k\\)-tensors and \\(k\\)-forms — print.stokes","text":"","code":"# S3 method for class 'kform' print(x, ...) # S3 method for class 'ktensor' print(x, ...)"},{"path":"https://robinhankin.github.io/stokes/reference/print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print methods for \\(k\\)-tensors and \\(k\\)-forms — print.stokes","text":"x \\(k\\)-form \\(k\\)-tensor ... arguments (currently ignored)","code":""},{"path":"https://robinhankin.github.io/stokes/reference/print.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print methods for \\(k\\)-tensors and \\(k\\)-forms — print.stokes","text":"Printing dispatched print.ktensor() print.kform() depending argument.  Special dispensation given zero object. Although \\(k\\)-forms alternating tensors thus mathematically tensors, handled differently. default print method uses spray print methods,   respects polyform option.  However, setting   polyform TRUE can give misleading output,   spray objects interpreted multivariate polynomials   differential forms (particular uses caret signify   powers). much better use options ktensor_symbolic_print   kform_symbolic_print instead: bespoke print methods   print.kform() print.ktensor() sensitive   options. kform objects, option kform_symbolic_print   non-null, print method uses .symbolic() give   alternate way displaying \\(k\\)-tensors \\(k\\)-forms.    generic non-null value option “x”   gives output like “dx1 ^ dx2”.  However,   two special values: set kform_symbolic_print   “dx” output like “dx ^ dz”   “txyz” output like “dt ^ dx”, useful   relativistic physics Minkowski metric.  See examples. ktensor objects, option ktensor_symbolic_print   TRUE, alphabetic system used.  define   \\(\\phi_i(x^j)=\\delta_i^j\\) print method uses   \\(\\phi_1=\\), \\(\\phi_2=b\\) .  entirely happy   might change future. detail given symbolic.Rd dx vignette.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print methods for \\(k\\)-tensors and \\(k\\)-forms — print.stokes","text":"Returns argument invisibly.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/print.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print methods for \\(k\\)-tensors and \\(k\\)-forms — print.stokes","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/print.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Print methods for \\(k\\)-tensors and \\(k\\)-forms — print.stokes","text":"kform ktensor objects,   print method asserts argument map \\(V^k\\)   \\(\\mathbb{R}\\) \\(V=\\mathbb{R}^n\\).  ,   \\(n\\) largest element index matrix.  However,   map naturally furnishes map \\((\\mathbb{R}^m)^k\\)   \\(\\mathbb{R}\\), provided \\(m\\geq n\\) via   natural projection \\(\\mathbb{R}^n\\)   \\(\\mathbb{R}^m\\).  Formally   \\(\\left(x_1,\\ldots,x_n\\right)\\mapsto\\left(x_1,\\ldots,x_n,0,\\ldots,0\\right)\\\\mathbb{R}^m\\).  case zero \\(k\\)-form   \\(k\\)-tensor, “n” interpreted   “\\(n\\geq 0\\)”.  See also dovs().","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print methods for \\(k\\)-tensors and \\(k\\)-forms — print.stokes","text":"","code":"a <- rform() a #> An alternating linear map from V^3 to R with V=R^7: #>            val #>  1 2 5  =   -8 #>  1 2 3  =   -6 #>  1 3 6  =    7 #>  4 5 6  =    9 #>  4 5 7  =   -2 #>  2 4 5  =    1 #>  2 4 7  =   -3 #>  2 3 5  =    1  options(kform_symbolic_print = \"x\") a #> An alternating linear map from V^3 to R with V=R^7: #>  -8 dx1^dx2^dx5 -6 dx1^dx2^dx3 +7 dx1^dx3^dx6 +9 dx4^dx5^dx6 -2 dx4^dx5^dx7 + dx2^dx4^dx5 -3 dx2^dx4^dx7 + dx2^dx3^dx5    options(kform_symbolic_print = \"dx\") kform(spray(kform_basis(3,2),1:3)) #> An alternating linear map from V^2 to R with V=R^3: #>  +3 dy^dz +2 dx^dz + dx^dy    kform(spray(kform_basis(4,2),1:6))  # runs out of symbols #> An alternating linear map from V^2 to R with V=R^4: #>  +6 dz^dNA +5 dy^dNA +4 dx^dNA +3 dy^dz +2 dx^dz + dx^dy    options(kform_symbolic_print = \"txyz\") kform(spray(kform_basis(4,2),1:6))  # standard notation #> An alternating linear map from V^2 to R with V=R^4: #>  +6 dy^dz +5 dx^dz +4 dt^dz +3 dx^dy +2 dt^dy + dt^dx    options(kform_symbolic_print = NULL) # revert to default a #> An alternating linear map from V^3 to R with V=R^7: #>            val #>  1 2 5  =   -8 #>  1 2 3  =   -6 #>  1 3 6  =    7 #>  4 5 6  =    9 #>  4 5 7  =   -2 #>  2 4 5  =    1 #>  2 4 7  =   -3 #>  2 3 5  =    1"},{"path":"https://robinhankin.github.io/stokes/reference/rform.html","id":null,"dir":"Reference","previous_headings":"","what":"Random kforms and ktensors — rform","title":"Random kforms and ktensors — rform","text":"Random \\(k\\)-form objects \\(k\\)-tensors,   intended quick “get going” examples","code":""},{"path":"https://robinhankin.github.io/stokes/reference/rform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random kforms and ktensors — rform","text":"","code":"rform(terms=9,k=3,n=7,coeffs,ensure=TRUE) rtensor(terms=9,k=3,n=7,coeffs)"},{"path":"https://robinhankin.github.io/stokes/reference/rform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random kforms and ktensors — rform","text":"terms Number distinct terms k,n \\(k\\)-form maps \\(V^k\\)     \\(\\mathbb{R}\\), \\(V=\\mathbb{R}^n\\) coeffs coefficients form; missing use     seq_len(terms) ensure Boolean default TRUE meaning ensure     dovs() returned value fact equal     n.  FALSE, sometimes dovs() strictly     less n random sampling","code":""},{"path":"https://robinhankin.github.io/stokes/reference/rform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random kforms and ktensors — rform","text":"Random \\(k\\)-form objects \\(k\\)-tensors, moderate complexity. Note argument terms upper bound, index matrix   might contain repeats combined.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/rform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random kforms and ktensors — rform","text":"functions documented return object class kform   ktensor.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/rform.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random kforms and ktensors — rform","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/rform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random kforms and ktensors — rform","text":"","code":"(a <- rform()) #> An alternating linear map from V^3 to R with V=R^7: #>            val #>  1 4 7  =    6 #>  3 5 6  =   -8 #>  2 6 7  =    3 #>  2 3 5  =    2 #>  2 3 7  =   -2 #>  1 3 4  =    4 (b <- rform()) #> An alternating linear map from V^3 to R with V=R^7: #>            val #>  4 5 7  =    9 #>  1 2 6  =   -6 #>  1 3 6  =    4 #>  1 5 7  =    5 #>  1 6 7  =    4 #>  2 4 6  =    7 a ^ b #> An alternating linear map from V^6 to R with V=R^7: #>                  val #>  1 2 3 5 6 7  =   -8  a #> An alternating linear map from V^3 to R with V=R^7: #>            val #>  1 4 7  =    6 #>  3 5 6  =   -8 #>  2 6 7  =    3 #>  2 3 5  =    2 #>  2 3 7  =   -2 #>  1 3 4  =    4 a ^ dx #> An alternating linear map from V^4 to R with V=R^7: #>              val #>  1 2 3 5  =   -2 #>  1 2 3 7  =    2 #>  1 2 6 7  =   -3 #>  1 3 5 6  =    8 a ^ dx ^ dy #> An alternating linear map from V^5 to R with V=R^6: #>                val #>  1 2 3 5 6  =   -8  (x <- rtensor()) #> A linear map from V^3 to R with V=R^7: #>            val #>  1 4 7  =    8 #>  5 2 2  =   15 #>  5 1 5  =    5 #>  7 3 7  =    4 #>  3 1 7  =    2 #>  3 2 7  =    7 #>  5 1 4  =    3 #>  7 2 5  =    1 x %X% x #> A linear map from V^6 to R with V=R^7: #>                  val #>  7 2 5 7 2 5  =    1 #>  3 2 7 7 2 5  =    7 #>  3 1 7 7 3 7  =    8 #>  5 1 5 7 3 7  =   20 #>  7 2 5 3 1 7  =    2 #>  5 2 2 7 3 7  =   60 #>  3 1 7 5 1 4  =    6 #>  7 2 5 5 1 5  =    5 #>  5 2 2 5 1 5  =   75 #>  5 2 2 3 2 7  =  105 #>  7 3 7 7 3 7  =   16 #>  5 2 2 5 2 2  =  225 #>  3 2 7 5 1 4  =   21 #>  5 2 2 1 4 7  =  120 #>  1 4 7 5 2 2  =  120 #>  5 1 4 7 2 5  =    3 #>  1 4 7 5 1 5  =   40 #>  3 1 7 7 2 5  =    2 #>  7 2 5 5 2 2  =   15 #>  5 1 5 1 4 7  =   40 #>  5 1 5 5 1 5  =   25 #>  7 2 5 1 4 7  =    8 #>  5 1 4 7 3 7  =   12 #>  3 1 7 1 4 7  =   16 #>  5 1 4 5 1 5  =   15 #>  3 2 7 5 1 5  =   35 #>  3 2 7 3 1 7  =   14 #>  5 1 5 5 2 2  =   75 #>  3 2 7 7 3 7  =   28 #>  5 1 4 5 2 2  =   45 #>  3 2 7 5 2 2  =  105 #>  5 1 5 3 2 7  =   35 #>  3 1 7 5 1 5  =   10 #>  7 3 7 5 2 2  =   60 #>  3 2 7 3 2 7  =   49 #>  3 1 7 5 2 2  =   30 #>  5 2 2 3 1 7  =   30 #>  5 1 5 3 1 7  =   10 #>  7 3 7 3 1 7  =    8 #>  7 3 7 3 2 7  =   28 #>  3 2 7 1 4 7  =   56 #>  5 1 5 5 1 4  =   15 #>  3 1 7 3 1 7  =    4 #>  5 1 4 3 1 7  =    6 #>  1 4 7 3 2 7  =   56 #>  3 1 7 3 2 7  =   14 #>  1 4 7 7 3 7  =   32 #>  7 2 5 7 3 7  =    4 #>  5 1 4 3 2 7  =   21 #>  7 3 7 1 4 7  =   32 #>  5 1 4 1 4 7  =   24 #>  1 4 7 3 1 7  =   16 #>  7 2 5 3 2 7  =    7 #>  1 4 7 5 1 4  =   24 #>  7 3 7 7 2 5  =    4 #>  5 2 2 5 1 4  =   45 #>  7 3 7 5 1 4  =   12 #>  5 1 4 5 1 4  =    9 #>  7 2 5 5 1 4  =    3 #>  1 4 7 7 2 5  =    8 #>  7 3 7 5 1 5  =   20 #>  5 2 2 7 2 5  =   15 #>  1 4 7 1 4 7  =   64 #>  5 1 5 7 2 5  =    5"},{"path":"https://robinhankin.github.io/stokes/reference/scalar.html","id":null,"dir":"Reference","previous_headings":"","what":"Scalars and losing attributes — scalar","title":"Scalars and losing attributes — scalar","text":"Scalars: \\(0\\)-forms \\(0\\)-tensors","code":""},{"path":"https://robinhankin.github.io/stokes/reference/scalar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scalars and losing attributes — scalar","text":"","code":"scalar(s,kform=TRUE,lose=FALSE) is.scalar(M) `0form`(s = 1, lose = FALSE) `0tensor`(s = 1, lose = FALSE) # S3 method for class 'kform' lose(M) # S3 method for class 'ktensor' lose(M)"},{"path":"https://robinhankin.github.io/stokes/reference/scalar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scalars and losing attributes — scalar","text":"s scalar value; number kform Boolean default TRUE meaning return     kform FALSE meaning return ktensor M Object class ktensor kform lose function scalar(), Boolean TRUE     meaning return normal scalar, default FALSE meaning     return formal \\(0\\)-form \\(0\\)-tensor","code":""},{"path":"https://robinhankin.github.io/stokes/reference/scalar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scalars and losing attributes — scalar","text":"\\(k\\)-tensor (including \\(k\\)-forms) maps \\(k\\) vectors scalar.  \\(k=0\\), \\(0\\)-tensor maps vectors scalar, , mapping nothing scalar, normal people call plain old scalar.  forms created couple constructions package, specifically scalar(), kform_general(1,0) contract().  functions take lose argument behaves much like drop argument base extraction.  Functions 0form() 0tensor() wrappers scalar(). Function lose() takes object class ktensor kform , arity zero, returns coefficient. Note function kform() always returns kform object, never loses attributes. slight terminological problem.  \\(k\\)-form maps \\(k\\) vectors reals: \\(0\\)-form maps \\(0\\) vectors reals.  anyone planet call scalar.  Similarly, \\(0\\)-tensor maps \\(0\\) vectors reals, scalar.  Mathematically, difference \\(0\\)-forms \\(0\\)-tensors, package makes distinction: Compare zero tensors zero forms.  zero tensor maps \\(V^k\\) real number zero, zero form alternating tensor mapping \\(V^k\\) zero (zero tensor necessarily alternating).  See zero.Rd.","code":"> scalar(5,kform=TRUE) An alternating linear map from V^0 to R with V=R^0:      val   =    5 > scalar(5,kform=FALSE) A linear map from V^0 to R with V=R^0:      val   =    5 >"},{"path":"https://robinhankin.github.io/stokes/reference/scalar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scalars and losing attributes — scalar","text":"functions documented return object class   kform ktensor, except .scalar(),   returns Boolean.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/scalar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Scalars and losing attributes — scalar","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/scalar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scalars and losing attributes — scalar","text":"","code":"o <- scalar(5) o #> An alternating linear map from V^0 to R with V=R^0: #>      val #>   =    5 lose(o) #> [1] 5  kform_general(1,0)   #> [1] 1 kform_general(1,0,lose=FALSE) #> An alternating linear map from V^0 to R with V=R^0: #>      val #>   =    1"},{"path":"https://robinhankin.github.io/stokes/reference/stokes-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The Exterior Calculus — stokes-package","title":"The Exterior Calculus — stokes-package","text":"Provides functionality working tensors, alternating            forms, wedge products, Stokes's theorem, related concepts \t   exterior calculus.  Uses 'disordR' discipline \t   (Hankin, 2022, <doi:10.48550/arXiv.2210.03856>).  \t   canonical reference M. Spivak \t   (1965, ISBN:0-8053-9021-9) \"Calculus Manifolds\".  cite \t   package publications please use Hankin (2022)            <doi:10.48550/arXiv.2210.17008>.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/stokes-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Exterior Calculus — stokes-package","text":"DESCRIPTION file: package yet installed build time.   Index:  package yet installed build time. Generally package, arguments \\(k\\)-forms denoted K, \\(k\\)-tensors U, spray objects S.  Multilinear maps (may either \\(k\\)-forms \\(k\\)-tensors) denoted M.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/stokes-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The Exterior Calculus — stokes-package","text":"Robin K. S. Hankin [aut, cre] (<https://orcid.org/0000-0001-5982-0415>) Maintainer: Robin K. S. Hankin <hankin.robin@gmail.com>","code":""},{"path":"https://robinhankin.github.io/stokes/reference/stokes-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Exterior Calculus — stokes-package","text":"M. Spivak 1971. Calculus manifolds,     Addison-Wesley. R. K. S. Hankin 2022.  “Disordered vectors R:     introducing disordR package.”     https://arxiv.org/abs/2210.03856. R. K. S. Hankin 2022.  “Sparse arrays R:     spray package.  https://arxiv.org/abs/2210.03856.”","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/stokes-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Exterior Calculus — stokes-package","text":"","code":"## Some k-tensors: U1 <- as.ktensor(matrix(1:15,5,3)) U2 <- as.ktensor(cbind(1:3,2:4),1:3)  ## Coerce a tensor to functional form, here mapping V^3  -> R (here V=R^15): as.function(U1)(matrix(rnorm(45),15,3)) #> [1] -1.657814  ## Tensor product is tensorprod() or %X%: U1 %X% U2 #> A linear map from V^5 to R with V=R^15: #>                  val #>  1  6 11 1 2  =    1 #>  2  7 12 1 2  =    1 #>  4  9 14 3 4  =    3 #>  1  6 11 3 4  =    3 #>  3  8 13 3 4  =    3 #>  5 10 15 3 4  =    3 #>  3  8 13 1 2  =    1 #>  1  6 11 2 3  =    2 #>  2  7 12 3 4  =    3 #>  5 10 15 2 3  =    2 #>  4  9 14 2 3  =    2 #>  3  8 13 2 3  =    2 #>  2  7 12 2 3  =    2 #>  5 10 15 1 2  =    1 #>  4  9 14 1 2  =    1   ## A k-form is an alternating k-tensor: K1 <- as.kform(cbind(1:5,2:6),rnorm(5)) K2 <- kform_general(3:6,2,1:6) K3 <- rform(9,3,9,runif(9))  ## The distributive law is true  (K1 + K2) ^ K3 == K1 ^ K3 + K2 ^ K3 # TRUE to numerical precision #> [1] FALSE  ## Wedge product is associative (non-trivial): (K1 ^ K2) ^ K3 #> An alternating linear map from V^7 to R with V=R^9: #>                           val #>  1 2 3 4 5 6 9  =  -0.4304560 #>  2 3 4 5 6 7 8  =   1.2361588 #>  2 3 4 5 6 8 9  =   0.4861741 #>  1 2 3 4 6 8 9  =   0.1438165 #>  1 2 4 5 6 8 9  =   0.4314494 #>  1 2 3 4 5 6 7  =  -2.9728270 #>  1 2 3 4 6 7 8  =  -4.0184170 #>  1 2 3 5 6 7 8  =  -3.9444890 #>  1 2 4 5 6 7 8  =   1.0970143 #>  1 2 3 5 6 8 9  =   0.2876329 #>  1 2 3 4 5 6 8  =  -6.0991398 #>  1 2 3 4 5 7 8  =  -2.3379159 K1 ^ (K2 ^ K3) #> An alternating linear map from V^7 to R with V=R^9: #>                           val #>  1 2 3 4 5 7 8  =  -2.3379159 #>  1 2 3 4 5 6 8  =  -6.0991398 #>  1 2 3 5 6 7 8  =  -3.9444890 #>  1 2 3 4 6 8 9  =   0.1438165 #>  2 3 4 5 6 7 8  =   1.2361588 #>  1 2 4 5 6 7 8  =   1.0970143 #>  1 2 3 5 6 8 9  =   0.2876329 #>  2 3 4 5 6 8 9  =   0.4861741 #>  1 2 3 4 5 6 7  =  -2.9728270 #>  1 2 4 5 6 8 9  =   0.4314494 #>  1 2 3 4 6 7 8  =  -4.0184170 #>  1 2 3 4 5 6 9  =  -0.4304560   ## k-forms can be coerced to a function and wedge product: f <- as.function(K1 ^ K2 ^ K3)  ## E is a a random point in V^k: E <- matrix(rnorm(63),9,7)  ## f() is alternating: f(E) #> [1] 22.86506 f(E[,7:1]) #> [1] -22.86506    ## The package blurs the distinction between symbolic and numeric computing: dx <- as.kform(1) dy <- as.kform(2) dz <- as.kform(3)  dx ^ dy ^ dz #> An alternating linear map from V^3 to R with V=R^3: #>            val #>  1 2 3  =    1  K3 ^ dx ^ dy ^ dz #> An alternating linear map from V^6 to R with V=R^9: #>                         val #>  1 2 3 6 8 9  =   0.2068019 #>  1 2 3 4 7 8  =   0.2629099 #>  1 2 3 4 6 8  =   0.7927355 #>  1 2 3 4 5 8  =  -1.7962075 #>  1 2 3 5 6 9  =  -0.6189772"},{"path":"https://robinhankin.github.io/stokes/reference/summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summaries of tensors and alternating forms — summary.stokes","title":"Summaries of tensors and alternating forms — summary.stokes","text":"summary method tensors alternating forms, print method summaries.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summaries of tensors and alternating forms — summary.stokes","text":"","code":"# S3 method for class 'kform' summary(object, ...) # S3 method for class 'ktensor' summary(object, ...) # S3 method for class 'summary.kform' print(x, ...) # S3 method for class 'summary.ktensor' print(x, ...)"},{"path":"https://robinhankin.github.io/stokes/reference/summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summaries of tensors and alternating forms — summary.stokes","text":"object,x Object class ktensor kform ... arguments, passed head()","code":""},{"path":"https://robinhankin.github.io/stokes/reference/summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summaries of tensors and alternating forms — summary.stokes","text":"Summary methods tensors alternating forms.  Uses spray::summary().","code":""},{"path":"https://robinhankin.github.io/stokes/reference/summary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summaries of tensors and alternating forms — summary.stokes","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summaries of tensors and alternating forms — summary.stokes","text":"","code":"a <- rform(100) summary(a) #> A kform object with 34 terms.  Summary of coefficients:  #>  #> a disord object with hash 4980e9a3db7bc1be348d56b5f8fa4354afbf3db5  #>  #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #> -242.00  -84.00  -36.00  -29.65   44.00  106.00  #>  #>  #> Representative selection of index and coefficients: #>  #> An alternating linear map from V^3 to R with V=R^7: #>             val #>  2 4 5  =    37 #>  1 5 6  =    65 #>  2 3 5  =    84 #>  1 6 7  =  -190 #>  1 3 6  =   -43 #>  1 3 5  =   -81 options(kform_symbolic_print = TRUE) summary(a) #> A kform object with 34 terms.  Summary of coefficients:  #>  #> a disord object with hash 4980e9a3db7bc1be348d56b5f8fa4354afbf3db5  #>  #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #> -242.00  -84.00  -36.00  -29.65   44.00  106.00  #>  #>  #> Representative selection of index and coefficients: #>  #> An alternating linear map from V^3 to R with V=R^7: #>  +37 dy^dNA^dNA +65 dx^dNA^dNA +84 dy^dz^dNA -190 dx^dNA^dNA -43 dx^dz^dNA -81 dx^dz^dNA  options(kform_symbolic_print = NULL)  # restore default"},{"path":"https://robinhankin.github.io/stokes/reference/symbolic.html","id":null,"dir":"Reference","previous_headings":"","what":"Symbolic form — symbolic","title":"Symbolic form — symbolic","text":"Returns character string representing \\(k\\)-tensor   \\(k\\)-form objects symbolic form.  Used print method   either option kform_symbolic_print   ktensor_symbolic_print non-null.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/symbolic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Symbolic form — symbolic","text":"","code":"as.symbolic(M,symbols=letters,d=\"\")"},{"path":"https://robinhankin.github.io/stokes/reference/symbolic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Symbolic form — symbolic","text":"M Object class kform ktensor; map     \\(V^k\\) \\(\\mathbb{R}\\),     \\(V=\\mathbb{R}^n\\) symbols character vector giving names symbols d String specifying appearance differential operator","code":""},{"path":"https://robinhankin.github.io/stokes/reference/symbolic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Symbolic form — symbolic","text":"Spivak (p89), archetypically terse writing, states: function \\(f\\) considered 0-form \\(f\\cdot\\omega\\) also written \\(f\\wedge\\omega\\).  \\(f\\colon\\mathbb{R}^n\\longrightarrow\\mathbb{R}\\) differentiable, \\(Df(p)\\\\Lambda^1\\left(\\mathbb{R}^n\\right)\\). minor modification therefore obtain 1-form \\(\\mathrm{d}f\\), defined $$\\mathrm{d}f(p)\\left(v_p\\right)=Df(p)(v).$$ Let us consider particular 1-forms   \\(\\mathrm{d}\\pi^\\).  customary let   \\(x^\\) denote function \\(\\pi^\\) (\\(\\mathbb{R}^3\\) often denote \\(x^1\\),   \\(x^2\\), \\(x^3\\) \\(x\\), \\(y\\),   \\(z\\)).  standard notation obvious disadvantages   allows many classical results expressed formulas equally   classical appearance.  Since   \\(\\mathrm{d}x^(p)(v_p)=\\mathrm{d}\\pi^(p)(v_p)=D\\pi^(p)(v)=v^\\), see   \\(\\mathrm{d}x^1(p),\\ldots,\\mathrm{d}x^n(p)\\)   just dual basis   \\((e_1)_p,\\ldots,(e_n)_p\\).  Thus every   k-form \\(\\omega\\) can written $$     \\omega=\\sum_{i_1 < \\cdots < i_k}\\omega_{i_1,\\ldots,i_k}     \\mathrm{d}x^{i_1}\\wedge\\cdots\\wedge\\mathrm{d}x^{i_k}.$$ Function .symbolic() uses format.  completeness,   add (p77) \\(k\\)-tensors may expressed form $$     \\sum_{i_1,\\ldots, i_k=1}^n a_{i_1,\\ldots,i_k}\\cdot \\phi_{i_1}\\otimes\\cdots\\otimes\\phi_{i_k}.$$ form used \\(k\\)-tensors.  print method tensors, print.ktensor(), defines \\(=\\phi_1\\), \\(b=\\phi_2\\), .","code":""},{"path":"https://robinhankin.github.io/stokes/reference/symbolic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Symbolic form — symbolic","text":"Returns “noquote” character string.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/symbolic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Symbolic form — symbolic","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/symbolic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Symbolic form — symbolic","text":"","code":"(o <- kform_general(3,2,1:3)) #> An alternating linear map from V^2 to R with V=R^3: #>          val #>  2 3  =    3 #>  1 3  =    2 #>  1 2  =    1 as.symbolic(o,d=\"d\",symbols=letters[23:26]) #> [1]  +3 dx^dy +2 dw^dy + dw^dx  (a <- rform(n=50)) #> An alternating linear map from V^3 to R with V=R^49: #>               val #>   3 20 38  =    9 #>   4 14 22  =   -7 #>   3 36 40  =   -5 #>  25 28 34  =    4 #>   1 20 44  =   -6 #>  28 38 49  =   -3 #>   6 11 22  =    8 #>   9 16 28  =   -2 as.symbolic(a,symbols=state.abb) #> [1]  +9 AZ^MD^PA -7 AR^IN^MI -5 AZ^OK^SC +4 MO^NV^ND -6 AL^MD^UT -3 NV^PA^WI +8 CO^HI^MI -2 FL^KS^NV"},{"path":"https://robinhankin.github.io/stokes/reference/tensorprod.html","id":null,"dir":"Reference","previous_headings":"","what":"Tensor products of \\(k\\)-tensors — tensorprod","title":"Tensor products of \\(k\\)-tensors — tensorprod","text":"Tensor products \\(k\\)-tensors","code":""},{"path":"https://robinhankin.github.io/stokes/reference/tensorprod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tensor products of \\(k\\)-tensors — tensorprod","text":"","code":"tensorprod(U, ...) tensorprod2(U1,U2)"},{"path":"https://robinhankin.github.io/stokes/reference/tensorprod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tensor products of \\(k\\)-tensors — tensorprod","text":"U,U1,U2 Object class ktensor ... arguments, currently ignored","code":""},{"path":"https://robinhankin.github.io/stokes/reference/tensorprod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tensor products of \\(k\\)-tensors — tensorprod","text":"Given \\(k\\)-tensor \\(S\\) \\(l\\)-tensor \\(T\\), can form tensor product \\(S\\otimes T\\), defined $$S\\otimes T\\left(v_1,\\ldots,v_k,v_{k+1},\\ldots, v_{k+l}\\right)=   S\\left(v_1,\\ldots v_k\\right)\\cdot T\\left(v_{k+1},\\ldots   v_{k+l}\\right).$$ Package idiom includes tensorprod(S,T) S %X% T; note tensor product commutative.  Function tensorprod() can take number arguments (result well-defined tensor product associative); uses tensorprod2() low-level helper function.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/tensorprod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tensor products of \\(k\\)-tensors — tensorprod","text":"functions documented return spray object.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/tensorprod.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Tensor products of \\(k\\)-tensors — tensorprod","text":"Spivak 1961","code":""},{"path":"https://robinhankin.github.io/stokes/reference/tensorprod.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Tensor products of \\(k\\)-tensors — tensorprod","text":"binary form %X% uses uppercase X avoid clashing %x% Kronecker product base R.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/tensorprod.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Tensor products of \\(k\\)-tensors — tensorprod","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/tensorprod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tensor products of \\(k\\)-tensors — tensorprod","text":"","code":"(A <- ktensor(spray(matrix(c(1,1,2,2,3,3),2,3,byrow=TRUE),1:2))) #> A linear map from V^3 to R with V=R^3: #>            val #>  2 3 3  =    2 #>  1 1 2  =    1 (B <- ktensor(spray(10+matrix(4:9,3,2),5:7))) #> A linear map from V^2 to R with V=R^19: #>            val #>  16 19  =    7 #>  15 18  =    6 #>  14 17  =    5 tensorprod(A,B) #> A linear map from V^5 to R with V=R^19: #>                  val #>  1 1 2 14 17  =    5 #>  2 3 3 14 17  =   10 #>  1 1 2 15 18  =    6 #>  2 3 3 15 18  =   12 #>  1 1 2 16 19  =    7 #>  2 3 3 16 19  =   14  A %X% B - B %X% A #> A linear map from V^5 to R with V=R^19: #>                    val #>   2  3 3 16 19  =   14 #>   1  1 2 16 19  =    7 #>   2  3 3 15 18  =   12 #>  16 19 1  1  2  =   -7 #>   1  1 2 15 18  =    6 #>   2  3 3 14 17  =   10 #>   1  1 2 14 17  =    5 #>  16 19 2  3  3  =  -14 #>  15 18 2  3  3  =  -12 #>  14 17 2  3  3  =  -10 #>  15 18 1  1  2  =   -6 #>  14 17 1  1  2  =   -5   Va <- matrix(rnorm(9),3,3) Vb <- matrix(rnorm(38),19,2)  LHS <- as.function(A %X% B)(cbind(rbind(Va,matrix(0,19-3,3)),Vb)) RHS <-  as.function(A)(Va) * as.function(B)(Vb)  c(LHS=LHS,RHS=RHS,diff=LHS-RHS) #>       LHS       RHS      diff  #> -0.582478 -0.582478  0.000000"},{"path":"https://robinhankin.github.io/stokes/reference/transform.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear transforms of \\(k\\)-forms — transform","title":"Linear transforms of \\(k\\)-forms — transform","text":"Given \\(k\\)-form, express terms linear   combinations \\(dx_i\\)","code":""},{"path":"https://robinhankin.github.io/stokes/reference/transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear transforms of \\(k\\)-forms — transform","text":"","code":"pullback(K,M) stretch(K,d)"},{"path":"https://robinhankin.github.io/stokes/reference/transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear transforms of \\(k\\)-forms — transform","text":"K Object class kform M Matrix transformation d Numeric vector representing diagonal elements     diagonal matrix","code":""},{"path":"https://robinhankin.github.io/stokes/reference/transform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Linear transforms of \\(k\\)-forms — transform","text":"Function pullback() calculates pullback function.    vignette provided pullback.Rmd. Suppose given two-form $$     \\omega=\\sum_{< j}a_{ij}\\mathrm{d}x_i\\wedge\\mathrm{d}x_j$$ relationships $$\\mathrm{d}x_i=\\sum_rM_{ir}\\mathrm{d}y_r$$ $$\\omega =     \\sum_{< j}     a_{ij}\\left(\\sum_rM_{ir}\\mathrm{d}y_r\\right)\\wedge\\left(\\sum_rM_{jr}\\mathrm{d}y_r\\right).   $$ general situation  \\(k\\)-form   $$     \\omega=\\sum_{i_1 < \\cdots < i_k}a_{i_1\\ldots i_k}\\mathrm{d}x_{i_1}\\wedge\\cdots\\wedge\\mathrm{d}x_{i_k}$$ giving $$\\omega =     \\sum_{i_1 < \\cdots < i_k}\\left[     a_{i_1,\\ldots, i_k}\\left(\\sum_rM_{i_1r}\\mathrm{d}y_r\\right)\\wedge\\cdots\\wedge\\left(\\sum_rM_{i_kr}\\mathrm{d}y_r\\right)\\right].   $$ transform() function slow.  100% sure much efficient way transformation.  tests tests/testthat discussion stokes vignette. Function stretch() carries operation \\(M\\) diagonal matrix.  much faster transform().","code":""},{"path":"https://robinhankin.github.io/stokes/reference/transform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear transforms of \\(k\\)-forms — transform","text":"functions documented return object class   kform.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/transform.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Linear transforms of \\(k\\)-forms — transform","text":"S. H. Weintraub 2019. Differential forms: theory practice.   Elsevier.  (Chapter 3)","code":""},{"path":"https://robinhankin.github.io/stokes/reference/transform.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Linear transforms of \\(k\\)-forms — transform","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/transform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear transforms of \\(k\\)-forms — transform","text":"","code":"# Example in the text: K <- as.kform(matrix(c(1,1,2,3),2,2),c(1,5)) M <- matrix(1:9,3,3) pullback(K,M) #> An alternating linear map from V^2 to R with V=R^3: #>          val #>  1 2  =  -33 #>  1 3  =  -66 #>  2 3  =  -33  # Demonstrate that the result can be complicated: M <- matrix(rnorm(25),5,5) pullback(as.kform(1:2),M) #> An alternating linear map from V^2 to R with V=R^5: #>                 val #>  3 5  =  -0.9831194 #>  1 2  =  -0.3699093 #>  2 4  =  -0.2072993 #>  1 5  =  -0.5493748 #>  2 5  =   0.9650675 #>  3 4  =   0.2702702 #>  4 5  =   0.0605190 #>  1 4  =   0.0948104 #>  2 3  =  -0.9423322 #>  1 3  =   0.9132611  # Numerical verification: o <- volume(3)  o2 <- pullback(pullback(o,M),solve(M)) max(abs(coeffs(o-o2))) # zero to numerical precision #> [1] 4.718448e-16  # Following should be zero: pullback(as.kform(1),M)-as.kform(matrix(1:5),c(crossprod(M,c(1,rep(0,4))))) #> The zero alternating linear map from V^1 to R with V=R^n: #> empty sparse array with 1 columns  # Following should be TRUE: issmall(pullback(o,crossprod(matrix(rnorm(10),2,5)))) #> [1] TRUE  # Some stretch() use-cases:  p <- rform() p #> An alternating linear map from V^3 to R with V=R^7: #>            val #>  1 3 6  =   -8 #>  1 2 5  =   -6 #>  2 6 7  =    5 #>  3 6 7  =  -13 #>  1 2 6  =    3 #>  4 6 7  =    7 #>  2 4 7  =   -2 #>  1 3 5  =   -1 stretch(p,seq_len(7)) #> An alternating linear map from V^3 to R with V=R^7: #>              val #>  1 3 5  =    -15 #>  2 4 7  =   -112 #>  4 6 7  =   1176 #>  1 2 6  =     36 #>  3 6 7  =  -1638 #>  2 6 7  =    420 #>  1 2 5  =    -60 #>  1 3 6  =   -144 stretch(p,c(1,0,0,1,1,1,1))   # kills dimensions 2 and 3 #> An alternating linear map from V^3 to R with V=R^7: #>            val #>  4 6 7  =    7"},{"path":"https://robinhankin.github.io/stokes/reference/vector_cross_product.html","id":null,"dir":"Reference","previous_headings":"","what":"The Vector cross product — vector_cross_product","title":"The Vector cross product — vector_cross_product","text":"vector cross product \\(\\mathbf{u}\\times\\mathbf{v}\\)   \\(\\mathbf{u},\\mathbf{u}\\\\mathbb{R}^3\\) defined   elementary school $$     \\mathbf{u}\\times\\mathbf{v}=\\left(u_2v_3-u_3v_2,u_2v_3-u_3v_2,u_2v_3-u_3v_2\\right).   $$ Function vcp3() convenience wrapper .  However, vector cross product may easily generalized product \\(n-1\\)-tuples vectors \\(\\mathbb{R}^n\\), given package function vector_cross_product(). Vignette vector_cross_product, supplied package, gives extensive discussion vector cross products, including formal definitions verification identities.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/vector_cross_product.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Vector cross product — vector_cross_product","text":"","code":"vector_cross_product(M) vcp3(u,v)"},{"path":"https://robinhankin.github.io/stokes/reference/vector_cross_product.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Vector cross product — vector_cross_product","text":"M Matrix one row column; columns interpreted   vectors u,v Vectors length 3, representing vectors \\(\\mathbb{R}^3\\)","code":""},{"path":"https://robinhankin.github.io/stokes/reference/vector_cross_product.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Vector cross product — vector_cross_product","text":"Returns vector","code":""},{"path":"https://robinhankin.github.io/stokes/reference/vector_cross_product.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Vector cross product — vector_cross_product","text":"joint function profile vector_cross_product() vcp3() given package vignette(\"vector_cross_product\").","code":""},{"path":"https://robinhankin.github.io/stokes/reference/vector_cross_product.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The Vector cross product — vector_cross_product","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/vector_cross_product.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Vector cross product — vector_cross_product","text":"","code":"vector_cross_product(matrix(1:6,3,2)) #> [1] -3  6 -3   M <- matrix(rnorm(30),6,5) LHS <- hodge(as.1form(M[,1])^as.1form(M[,2])^as.1form(M[,3])^as.1form(M[,4])^as.1form(M[,5])) RHS <- as.1form(vector_cross_product(M)) LHS-RHS  # zero to numerical precision #> An alternating linear map from V^1 to R with V=R^6: #>        val #>  6  =    0 #>  3  =    0 #>  4  =    0 #>  2  =    0 #>  5  =    0  # Alternatively: hodge(Reduce(`^`,sapply(seq_len(5),function(i){as.1form(M[,i])},simplify=FALSE))) #> An alternating linear map from V^1 to R with V=R^6: #>               val #>  4  =   1.0900990 #>  3  =  -0.0543601 #>  1  =   2.9527836 #>  5  =   2.9756167 #>  2  =  -0.0278315 #>  6  =   3.2427015"},{"path":"https://robinhankin.github.io/stokes/reference/volume.html","id":null,"dir":"Reference","previous_headings":"","what":"The volume element — volume","title":"The volume element — volume","text":"volume element \\(n\\) dimensions","code":""},{"path":"https://robinhankin.github.io/stokes/reference/volume.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The volume element — volume","text":"","code":"volume(n) is.volume(K,n=dovs(K))"},{"path":"https://robinhankin.github.io/stokes/reference/volume.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The volume element — volume","text":"n Dimension space K Object class kform","code":""},{"path":"https://robinhankin.github.io/stokes/reference/volume.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The volume element — volume","text":"Spivak phrases well (theorem 4.6, page 82): \\(V\\) dimension \\(n\\), follows \\(\\Lambda^n(V)\\) dimension 1. Thus alternating \\(n\\)-tensors \\(V\\) multiples non-zero one. Since determinant example member \\(\\Lambda^n(V)\\) surprising find following theorem: Let \\(v_1,\\ldots,v_n\\) basis \\(V\\) let \\(\\omega\\\\Lambda^n(V)\\).  \\(w_i=\\sum_{j=1}^n a_{ij}v_j\\)  $$   \\omega\\left(w_1,\\ldots,w_n\\right)=\\det\\left(a_{ij}\\right)\\cdot\\omega\\left(v_1,\\ldots   v_n\\right)$$ (see examples numerical verification ). Neither zero \\(k\\)-form, scalars, considered volume element.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/volume.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The volume element — volume","text":"Function volume() returns object class kform;   function .volume() returns Boolean.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/volume.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The volume element — volume","text":"M. Spivak 1971. Calculus manifolds,   Addison-Wesley","code":""},{"path":"https://robinhankin.github.io/stokes/reference/volume.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The volume element — volume","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/volume.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The volume element — volume","text":"","code":"dx^dy^dz == volume(3)  #> [1] TRUE  p <- 1 for(i in 1:7){p <- p ^ as.kform(i)} p #> An alternating linear map from V^7 to R with V=R^7: #>                    val #>  1 2 3 4 5 6 7  =    1 p == volume(7)  # should be TRUE #> [1] TRUE  o <- volume(5) M <- matrix(runif(25),5,5) det(M) - as.function(o)(M)   # should be zero #> [1] 0   is.volume(d(1) ^ d(2) ^ d(3) ^ d(4)) #> [1] TRUE is.volume(d(1:9)) #> [1] TRUE"},{"path":"https://robinhankin.github.io/stokes/reference/wedge.html","id":null,"dir":"Reference","previous_headings":"","what":"Wedge products — wedge","title":"Wedge products — wedge","text":"Wedge products \\(k\\)-forms","code":""},{"path":"https://robinhankin.github.io/stokes/reference/wedge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wedge products — wedge","text":"","code":"wedge2(K1,K2) wedge(x, ...)"},{"path":"https://robinhankin.github.io/stokes/reference/wedge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wedge products — wedge","text":"K1,K2,x,... \\(k\\)-forms","code":""},{"path":"https://robinhankin.github.io/stokes/reference/wedge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wedge products — wedge","text":"Wedge product \\(k\\)-forms.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/wedge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wedge products — wedge","text":"functions documented return object class   kform.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/wedge.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Wedge products — wedge","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/wedge.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Wedge products — wedge","text":"general use, use wedge() ^ %^%,   documented Ops.  Function wedge() uses low-level   helper function wedge2(), takes two arguments. short vignette provided package: type   vignette(\"wedge\") commandline.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/wedge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wedge products — wedge","text":"","code":"k1 <- as.kform(cbind(1:5,2:6),1:5) k2 <- as.kform(cbind(5:7,6:8,7:9),1:3) k3 <- kform_general(1:6,2)  a1 <- wedge2(k1,wedge2(k2,k3)) a2 <- wedge2(wedge2(k1,k2),k3)  is.zero(a1-a2)  # NB terms of a1, a2 in a different order! #> [1] TRUE  # This is why wedge(k1,k2,k3) is well-defined.  Can also use ^: k1 ^ k2 ^ k3 #> An alternating linear map from V^7 to R with V=R^9: #>                    val #>  2 3 4 5 7 8 9  =   27 #>  1 2 3 5 6 7 8  =    6 #>  1 2 5 6 7 8 9  =   18 #>  1 3 4 5 6 7 8  =   14 #>  1 2 4 6 7 8 9  =    3 #>  2 3 5 6 7 8 9  =   21 #>  1 3 4 5 7 8 9  =   21 #>  2 3 4 6 7 8 9  =   15 #>  2 4 5 6 7 8 9  =   27 #>  1 2 3 5 7 8 9  =    9 #>  1 2 3 4 5 6 7  =    6 #>  1 2 4 5 6 7 8  =   10 #>  3 4 5 6 7 8 9  =   36 #>  1 4 5 6 7 8 9  =   27 #>  1 2 4 5 7 8 9  =   15 #>  1 2 3 4 6 7 8  =   12 #>  2 3 4 5 6 7 8  =   18 #>  1 2 3 6 7 8 9  =    9 #>  1 2 3 4 7 8 9  =   18 #>  1 3 5 6 7 8 9  =   15 #>  1 3 4 6 7 8 9  =    9"},{"path":"https://robinhankin.github.io/stokes/reference/zap.html","id":null,"dir":"Reference","previous_headings":"","what":"Zap small values in \\(k\\)-forms and \\(k\\)-tensors — zap","title":"Zap small values in \\(k\\)-forms and \\(k\\)-tensors — zap","text":"Equivalent zapsmall()","code":""},{"path":"https://robinhankin.github.io/stokes/reference/zap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zap small values in \\(k\\)-forms and \\(k\\)-tensors — zap","text":"","code":"zap(X) # S3 method for class 'kform' zap(X) # S3 method for class 'ktensor' zap(X)"},{"path":"https://robinhankin.github.io/stokes/reference/zap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zap small values in \\(k\\)-forms and \\(k\\)-tensors — zap","text":"X Tensor \\(k\\)-form zapped","code":""},{"path":"https://robinhankin.github.io/stokes/reference/zap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Zap small values in \\(k\\)-forms and \\(k\\)-tensors — zap","text":"Given object class ktensor kform, coefficients   close zero ‘zapped’, .e., replaced ‘0’, using   base::zapsmall(). Note, zap() actually changes numeric value, just   print method.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/zap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zap small values in \\(k\\)-forms and \\(k\\)-tensors — zap","text":"Returns object class","code":""},{"path":"https://robinhankin.github.io/stokes/reference/zap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Zap small values in \\(k\\)-forms and \\(k\\)-tensors — zap","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/zap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zap small values in \\(k\\)-forms and \\(k\\)-tensors — zap","text":"","code":"S <- rform(7) S == zap(S) #> [1] TRUE"},{"path":"https://robinhankin.github.io/stokes/reference/zero.html","id":null,"dir":"Reference","previous_headings":"","what":"Zero tensors and zero forms — zero","title":"Zero tensors and zero forms — zero","text":"Correct idiom generating zero \\(k\\)-tensors \\(k\\)-forms","code":""},{"path":"https://robinhankin.github.io/stokes/reference/zero.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zero tensors and zero forms — zero","text":"","code":"zeroform(n) zerotensor(n) is.zero(x) is.empty(x)"},{"path":"https://robinhankin.github.io/stokes/reference/zero.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zero tensors and zero forms — zero","text":"n Arity \\(k\\)-form \\(k\\)-tensor x Object tested zero","code":""},{"path":"https://robinhankin.github.io/stokes/reference/zero.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Zero tensors and zero forms — zero","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/stokes/reference/zero.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Zero tensors and zero forms — zero","text":"Idiom .ktensor(rep(1,n),0)   .kform(rep(1,5),0) indeed .kform(1:5,0)   incorrect arity tensor lost. \\(0\\)-form thing zero tensor.    \\(0\\)-form maps \\(V^0\\) reals; scalar.  zero   tensor maps \\(V^k\\) zero.  discussion given   scalar.Rd.","code":""},{"path":"https://robinhankin.github.io/stokes/reference/zero.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zero tensors and zero forms — zero","text":"Returns object class kform ktensor.","code":""},{"path":[]},{"path":"https://robinhankin.github.io/stokes/reference/zero.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zero tensors and zero forms — zero","text":"","code":"zerotensor(5) #> The zero linear map from V^5 to R with V=R^n: #> empty sparse array with 5 columns zeroform(3) #> The zero alternating linear map from V^3 to R with V=R^n: #> empty sparse array with 3 columns   x <- rform(k=3) x*0 == zeroform(3)       # should be true #> [1] TRUE x   == x + zeroform(3)  # should be true #> [1] TRUE  y <- rtensor(k=3) y*0 == zerotensor(3)    # should be true #> [1] TRUE y   == y+zerotensor(3)  # should be true #> [1] TRUE   ## Following idiom is plausible but fails because as.ktensor(coeffs=0) ## and as.kform(coeffs=0) do not retain arity:  ## as.ktensor(1+diag(5)) +  as.ktensor(rep(1,5),0)   # fails ## as.kform(matrix(1:6,2,3)) + as.kform(1:3,0)   # also fails"},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-12-1","dir":"Changelog","previous_headings":"","what":"stokes 1.2-1","title":"stokes 1.2-1","text":"CRAN release: 2024-06-04 edge-cases vector_cross_product(), now works single 2D vector removal dependence emulator [favour quadform]","code":""},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-12-0","dir":"Changelog","previous_headings":"","what":"stokes 1.2-0","title":"stokes 1.2-0","text":"CRAN release: 2023-08-18 spray functionality imported, dependency removed consistentification vignettes","code":""},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-11-0","dir":"Changelog","previous_headings":"","what":"stokes 1.1-0","title":"stokes 1.1-0","text":"tighter integration spray disordR packages comparison operators != == numeric implemented .zero(0) now true [need drop()!] .one() added dependency magrittr removed; %>% now |>","code":""},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-11-1","dir":"Changelog","previous_headings":"","what":"stokes 1.1-1","title":"stokes 1.1-1","text":"CRAN release: 2022-01-06 Can use ^ place %^%","code":""},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-11-2","dir":"Changelog","previous_headings":"","what":"stokes 1.1-2","title":"stokes 1.1-2","text":"vector_cross_product() implemented new vignette","code":""},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-11-3","dir":"Changelog","previous_headings":"","what":"stokes 1.1-3","title":"stokes 1.1-3","text":"CRAN release: 2022-06-14 bugfix vignettes","code":""},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-11-4","dir":"Changelog","previous_headings":"","what":"stokes 1.1-4","title":"stokes 1.1-4","text":"New function 0tensor()","code":""},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-11-6","dir":"Changelog","previous_headings":"","what":"stokes 1.1-6","title":"stokes 1.1-6","text":"CRAN release: 2022-12-09 Improvements summary print methods citation points arXiv preprint tweaks vignettes remove overlooked dependence pracma","code":""},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-11-7","dir":"Changelog","previous_headings":"","what":"stokes 1.1-7","title":"stokes 1.1-7","text":"consistentification stokes vignette","code":""},{"path":"https://robinhankin.github.io/stokes/news/index.html","id":"stokes-12-0-1","dir":"Changelog","previous_headings":"","what":"stokes 1.2-0","title":"stokes 1.2-0","text":"CRAN release: 2023-08-18 arXiv preprint cited minor documentation improvements consistentification zero object spray package now imported rather attached coverage increased three-dimensional vector cross product redefined discussed vignette vector_cross_product","code":""}]
