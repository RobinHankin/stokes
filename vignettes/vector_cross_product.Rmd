---
title: "Function `vector_cross_product()` in the `stokes` package"
author: "Robin K. S. Hankin"
output: html_vignette
vignette: >
  %\VignetteIndexEntry{vector cross product}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<p style="text-align: right;">
![](`r system.file("help/figures/stokes.png", package = "stokes")`){width=10%}
</p>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(rmarkdown.html_vignette.check_title = FALSE)
library("stokes")
library("emulator")
set.seed(1)
```

```{r}
vector_cross_product
```

# The vector cross product

Spivak (p83) considers the standard vector cross product
$\mathbf{u}\times\mathbf{v}=\det\begin{pmatrix} i & j & k \\
u_1&u_2&u_3\\ v_1&v_2&v_3 \end{pmatrix}$ and places it in a more
general and rigorous context.  In a memorable passage, he states:

<div class="warning" style='padding:0.1em; background-color:#E9D8FD; color:#69337A'>
<span>
<p>

If $v_1,\ldots,v_{n-1}\in\mathbb{R}^n$ and $\phi$ is defined by

$$
\phi(w)=\det\left(\begin{array}{c}v_1\\ \vdots\\ v_{n-1}\\w\end{array}\right)
$$

then $\phi\in\Lambda^1\left(\mathbb{R}^n\right)$; therefore there is a
unique $z\in\mathbb{R}^n$ such that

$$
\left\langle w,z\right\rangle=\phi(w)=
\det\left(\begin{array}{c}v_1\\ \vdots\\ v_{n-1}\\w\end{array}\right).
$$	

This $z$ is denoted $v_1\times\ldots\times v_{n-1}$ and is called the
*cross product* of $v_1,\ldots,v_{n-1}$.

</p>
<p style='margin-bottom:1em; margin-right:1em; text-align:right; font-family:Georgia'> <b>- Michael Spivak, 1969</b> <i>(Calculus on Manifolds, Perseus books).  Pages 83-84</i>
</p></span>
</div>

The reason that $\mathbf{w}$ is at the bottom rather than the top is
that it ensures that the the $n$-tuple
$(\mathbf{v}_1,\ldots,\mathbf{v}_{n-1},\mathbf{w})$ has positive
orientation with respect to the standard basis vectors of
$\mathbb{R}^n$.  In $\mathbb{R}^3$ we get the standard elementary
mnemonic for $\mathbf{u}=(u_1,u_2,u_3)$, $\mathbf{v}=(v_1,v_2,v_3)$:

\[
\mathbf{u}\times\mathbf{v}=
\mathrm{det}
\begin{pmatrix}
i&j&k\\
u_1&u_2&u_3\\
v_1&v_2&v_3
\end{pmatrix}
\]


## R implementation {-}

The R function \code{vector_cross_product()} takes a matrix with $n$
rows and $n-1$ columns: the transpose of the work above.  This is
because `stokes` (and `R`) convention is to interpret _columns_ of a
matrix as vectors.  If we wanted to take the cross product of
$\mathbf{u}=(5,-2,1)$ with $\mathbf{v}=(1,2,0)$:

```{r}
(M <- cbind(c(5,-2,1),c(1,2,0)))
vector_cross_product(M)
```

But of course we can work with higher dimensional spaces:

```{r}
vector_cross_product(matrix(rnorm(30),6,5))
```

# Verification

We can demonstrate that the function has the correct orientation.  We
need to ensure that the vectors
$\mathbf{v}_1,\ldots,\mathbf{v}_n,\mathbf{v}_1\times\cdots\times\mathbf{v}_n$
constitute a right-handed basis:

```{r}
det(cbind(M,vector_cross_product(M)))>0
```

So it is right-handed in this case.  Here is a more severe test:

```{r}
f <- function(n){
  M <- matrix(rnorm(n^2+n),n+1,n)
  det(cbind(M,vector_cross_product(M)))>0
}

all(sapply(sample(3:10,100,replace=TRUE),f))
```

### Vector products and Hodge 

The cross product has a coordinate-free definition as the Hodge
conjugate of the wedge product of its arguments.  This is not used in
function `vector_cross_product()` because it is computationally
inefficient and (I think) prone to numerical roundoff errors.  We may
verify that the definitions agree, using a six-dimensional test case:

```{r}
set.seed(2)
M <- matrix(rnorm(30),6,5)
(ans1 <- vector_cross_product(M))
```

We can see that `vector_cross_product()` returns an R vector.  To
verify that this is correct, we compare the output with the value
calculated directly with the wedge product:

```{r}
hodge(as.1form(M[,1]) ^ as.1form(M[,2]) ^ as.1form(M[,3]) ^ as.1form(M[,4]) ^ as.1form(M[,5]))
```

Actually it is possible to produce the same answer using slightly
slicker idiom:

```{r}
(ans2 <- hodge(Reduce(`^`,lapply(1:5,function(i){as.1form(M[,i])}))))
```

[again note the different order in the output].  Above, we see that
the output of `vector_cross_product()` [`ans1`] is an ordinary R
vector, but the direct result [`ans2`] is a 1-form.  In order to
compare these, we first need to coerce `ans1` to a 1-form and then
subtract:

```{r}
(diff <- as.1form(ans1) - ans2)
coeffs(diff)
```

Above we see that `ans1` and `ans2` match to within numerical
precision.

##  Vector cross products in 3 dimensions

### Use of the `contract()` function

Taking Spivak's definition at face value, we could define the vector
cross product $\mathbf{u}\times\mathbf{v}$ of three-vectors
$\mathbf{u}$ and $\mathbf{v}$ as a map from the tangent space to the
reals, with $\left(\mathbf{u}\times\mathbf{v}\right)(\mathbf{w})=
\left(\mathbf{u}\times\mathbf{v}\right)\cdot\mathbf{w}
=\left(I_\mathbf{u}\right)_\mathbf{v}(\mathbf{w})$, where $I$ is the
3-volume element and subscripts refer to contraction.  This is easy to
implement in the package.  Suppose we wish to take the vector cross
product of $\mathbf{u}=\left(1,4,2\right)^T$ and
$\mathbf{v}=\left(2,1,5\right)^T$:

```{r label=definevcp}
u <- c(1,4,2)
v <- c(2,1,5)
(vcp <- contract(volume(3),cbind(u,v)))
dovs(vcp)
```

Object `vcp` is the vector cross product of $\mathbf{u}$ and
$\mathbf{v}$, but written a as a one-form.  We can see the mnemonic in
operation by coercing `vcp` to a function:


```{r}
ucv  <- as.function(vcp)
```

and then evaluating this on the three basis vectors of $\mathbb{R}^3$:

```{r label=faila}
c(i=ucv(ex), j=ucv(ey), k=ucv(ez))
```


and we see agreement with the mnemonic
$\det\begin{pmatrix}i&j&k\\1&4&2\\2&1&5\end{pmatrix}$.

It is possible to recreate the vector cross product more directly in
the package, but we need to coerce the R vectors `c(1,4,2)` and
`c(2,1,5)` to alternating $k$-forms first, using `as.1form()`.  Taking
a wedge product gives us a two-form, and to revert to a one form we
need to take the hodge dual:

```{r}
hodge(as.1form(c(1,4,2)) ^ as.1form(c(2,1,5)))
```

Above, note the order of the lines, being implementation-specific as
per `disordR` discipline, may appear in a different order but the form
should agree with the previous results.


## Reference

*  M. Spivak 1971. _Calculus on manifolds_, Addison-Wesley.


